{"totalbranchlevel":2,"branchnum":4,"term_id":82,"name":"复合型别","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"在计算机科学中，复合类型是一种数据类型，它可以原始类型和其它的复合类型所构成。构成一个复合类型的动作，又称作组合。","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:51:15.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"C/C++","totalbranchnum":0,"type":"branch","totalleafnum":17,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"struct是 C 和 C++ 的复合类型概念，是一个将字段或成员以一定组合方式所组成的数据类型。因为在宣告时，使用了关键字 struct，所以它简称为结构，或者更精确地说用户定义的数据结构。","fragment_id":"C/C++_1","scratchTime":"2016-12-20 09:51:15.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"在 C++ 里，struct 与class的唯一区别是默认的访问档次，class是私有的，struct 则是公有的。","fragment_id":"C/C++_2","scratchTime":"2016-12-20 09:51:15.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"注意尽管类的概念和关键字class是C++新引入的，C语言也已具备粗糙的 struct 类型。对于所有的意图和目的， C++ 的struct是 C struct 的超集：几乎所有合法的 C struct 也是合法的 C++ struct，并有着相同的语义。","fragment_id":"C/C++_3","scratchTime":"2016-12-20 09:51:15.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"struct 宣告组成一个字段清单，其中的每一个可以是任意类型。对于 struct 对象所需的存储区，即为全部字段的总合，再加上内部的补白。","fragment_id":"C/C++_4","scratchTime":"2016-12-20 09:51:15.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"struct Account {\n    int account_number;\n    char *first_name;\n    char *last_name;\n    float balance;\n };","fragment_id":"C/C++_5","scratchTime":"2016-12-20 09:51:15.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"定义一个称为 struct Account 的类型。若要创建此类型的新变量，可以写为 struct Account myAccount;，它有一个以 myAccount.account_number 访问的整数组件，且有一个以 myAccount.balance 访问的浮点数组件，以及 first_name 和 last_name 组件。myAccount 包含这四个数值，且这四个字段可各自改变。由于 struct account 的写法有些累赘，在 C 代码中，typedef 语句并不罕见，其为 struct 提供一个更简便的同义词。例如：","fragment_id":"C/C++_6","scratchTime":"2016-12-20 09:51:15.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"typedef struct Account_ {\n    int    account_number;\n    char   *first_name;\n    char   *last_name;\n    float  balance;\n } Account;","fragment_id":"C/C++_7","scratchTime":"2016-12-20 09:51:15.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"在 C++ 中，并不需要 typedef，因为使用了 struct 的类型定义，已是名字空间的一部分，所以该类型可称作 struct Account 或较简单的 Account。","fragment_id":"C/C++_8","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"其它例子，一个使用了浮点数数据类型的三维向量复合类型，可如此创建：","fragment_id":"C/C++_9","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"struct Vector {\n   float x;\n   float y;\n   float z;\n };","fragment_id":"C/C++_10","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"一个以 Vector 复合类型为类型的变量名 velocity，可以宣告为 Vector velocity;，可以用点运算符(.)访问 velocity 的成员。例如，velocity.x = 5;，会使 velocity 的组件 x 等于 5。","fragment_id":"C/C++_11","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"同样地，一个颜色结构可如此创建：","fragment_id":"C/C++_12","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"struct Color {\n   int red;\n   int green;\n   int blue;\n };","fragment_id":"C/C++_13","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"在三维图像中，必须经常不断追踪每一个顶点的位置和颜色。可以使用之前所创建的 Vector 和 Color 复合类型来创建 Vertex 复合类型：","fragment_id":"C/C++_14","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"struct Vertex {\n   Vector position;\n   Color color;\n };","fragment_id":"C/C++_15","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"以同样的格式创建一个 Vertex 类型的变量：Vertex v;，并以如下方式指派数值给 v ：","fragment_id":"C/C++_16","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"v.position.x = 0.0;\n   v.position.y = 1.5;\n   v.position.z = 0.0;\n   v.color.red = 128;\n   v.color.green = 0;\n   v.color.blue = 255;","fragment_id":"C/C++_17","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"原始子类型检查","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"刚开始使用的 struct，是用来建构组合数据类型，不过有时它是用来避开标准 C 协议，以创建原始子类型检查（primitive subtyping）。例如，共同的网络协议依赖于以下事实，C 编译器以可预料的方法，在结构字段之间补白；因此代码","fragment_id":"原始子类型检查_1","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%9E%8B%E5%88%AB","content":"struct ifoo_old_stub {\n    long x, y;\n };\n struct ifoo_version_42 {\n    long x, y, z;\n    char *name;\n    long a, b, c;\n };\n void operate_on_ifoo(struct ifoo_old_stub *);\n struct ifoo_version_42 s;\n . . .\n operate_on_ifoo(&s);","fragment_id":"原始子类型检查_2","scratchTime":"2016-12-20 09:51:16.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"参阅","totalbranchnum":0,"type":"branch","totalleafnum":0,"children":[]}]}
