{"totalbranchlevel":2,"branchnum":3,"term_id":22,"name":"斐波那契堆","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"斐波那契堆(Fibonacci heap)是计算机科学中树的集合。它比二项式堆具有更好的平摊分析性能，可用于实现合并优先队列。不涉及删除元素的操作有O(1)的平摊时间。 Extract-Min和Delete的数目和其它相比，较小时效率更佳。稠密图每次decrease key只要O(1)的平摊时间，和二项堆的O(lg n)相比是巨大的改进。","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"斐波纳契堆于1984年由Michael L. Fredman与Robert E. Tarjan提出，1987年公开发表。[1]名字来源于运行时分析使用的斐波那契数。","fragment_id":"摘要_2","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"结构","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"斐波那契堆是由一组最小堆有序树构成的。每个节点的度数为其子节点的数目。树的度数为其根节点的度数。","fragment_id":"结构_1","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"斐波那契堆中的树都是有根的但是无序。每个节点x包含指向父节点的指针p[x]和指向任意一个子结点的child[x]。x的所有子节点都用双向循环链表链接起来，叫做x的子链表。子链表中的每一个节点y都有指向它的左兄弟的left[y]和右兄弟的right[y]。如果节点y是x仅有的子节点，则left[y]=right[y]=y。","fragment_id":"结构_2","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"斐波那契堆中所有树的根节点也用一个双向循环链表链接起来。","fragment_id":"结构_3","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"使用一个指针指向斐波那契堆中最小元素。","fragment_id":"结构_4","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":1,"facet_name":"操作","totalbranchnum":7,"type":"branch","totalleafnum":7,"children":[{"totalbranchlevel":0,"facet_name":"建立一个新的斐波纳契堆","totalbranchnum":0,"type":"branch","totalleafnum":6,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"父节点p[x] 指向任一子女的指针child[x]——结点x的子女被链接成一个环形双链表，称为x的子女表 左兄弟left[x] 右兄弟right[x]——当left[x] = right[x] = x时，说明x是独子。 子女的个数degree[x] 布尔值域mark[x]——标记是否失去了一个孩子","fragment_id":"建立一个新的斐波纳契堆_1","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"//斐波那契结点ADT\n   struct FibonacciHeapNode {\n       int key;       //结点\n       int degree;    //度\n       FibonacciHeapNode * left;  //左兄弟\n       FibonacciHeapNode * right; //右兄弟\n       FibonacciHeapNode * parent; //父结点\n       FibonacciHeapNode * child;  //第一个孩子结点\n       bool marked;           //是否被删除第1个孩子\n   };\n   typedef FibonacciHeapNode FibNode;","fragment_id":"建立一个新的斐波纳契堆_2","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"对于一个给定的斐波那契堆H，可以通过指向包含最小关键字的树根的指针min[H]来访问，这个结点被称为斐波那契堆中的最小结点。如果一个斐波那契堆H是空的，则min[H] = NIL. 在一个斐波那契堆中，所有树的根都通过left和right指针链接成一个环形的双向链表，称为堆的根表。于是，指针min[H]就指向根表中具有最小关键字的结点。","fragment_id":"建立一个新的斐波纳契堆_3","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"//斐波那契堆ADT\n   struct FibonacciHeap {\n       int keyNum;   //堆中结点个数\n       FibonacciHeapNode * min;//最小堆，根结点\n       int maxNumOfDegree;   //最大度\n       FibonacciHeapNode * * cons;//指向最大度的内存区域\n   };\n   typedef FibonacciHeap FibHeap;","fragment_id":"建立一个新的斐波纳契堆_4","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"创建一个空的斐波那契堆，过程MAKE-FIB-HEAP 分配并返回一个斐波那契堆对象H；","fragment_id":"建立一个新的斐波纳契堆_5","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"//初始化一个空的Fibonacci Heap\n   FibHeap * FibHeapMake() {\n       FibHeap * heap = NULL;\n       heap = (FibHeap *) malloc(sizeof(FibHeap));\n       if (NULL == heap) {\n           puts(\"Out of Space!!\");\n           exit(1);\n       }\n       memset(heap, 0, sizeof(FibHeap));\n       return heap;\n   }\n    \n   //初始化结点x\n   FibNode * FibHeapNodeMake() {\n       FibNode * x = NULL;\n       x = (FibNode *) malloc(sizeof(FibNode));\n       if (NULL == x) {\n           puts(\"Out of Space!!\");\n           exit(1);\n       }\n       memset(x, 0, sizeof(FibNode));\n       x->left = x->right = x;\n       return x;\n   }","fragment_id":"建立一个新的斐波纳契堆_6","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"插入一个节点","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"创建一个仅包含一个节点的新的斐波纳契堆，然后执行堆合并。","fragment_id":"插入一个节点_1","scratchTime":"2016-12-20 09:40:44.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"查找最小的节点","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"由于用一个指针指向了具有最小值的根节点，因此查找最小的节点是平凡的操作。","fragment_id":"查找最小的节点_1","scratchTime":"2016-12-20 09:40:45.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"合并两个斐波纳契堆","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"简单合并两个斐波纳契堆的根表。即把两个斐波纳契堆的所有树的根首尾衔接并置。","fragment_id":"合并两个斐波纳契堆_1","scratchTime":"2016-12-20 09:40:45.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"释放（删除）最小的节点","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"查找最小的根节点并删除它，其所有的子节点都加入堆的根表，即它的子树都成为堆所包含的树； 需要查找并维护堆的最小根节点，但这耗时较大。为此，同时完成堆的维护：对堆当前包含的树的度数从低到高，迭代执行具有相同度数的树的合并并实现最小树化调整，使得堆包含的树具有不同的度数。这一步使用一个数组，数组下标为根节点的度数，数组的值为指向该根节点指针。如果发现具有相同度数的其他根节点则合并两棵树并维护该数组的状态。 对当前堆的所有根节点查找最小的根节点。","fragment_id":"释放（删除）最小的节点_1","scratchTime":"2016-12-20 09:40:45.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"降低一个节点的键值","totalbranchnum":0,"type":"branch","totalleafnum":3,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"对一个节点的键值降低后，自键值降低的节点开始自下而上的迭代执行下述操作，直至到根节点或一个未被标记（marked）节点为止：","fragment_id":"降低一个节点的键值_1","scratchTime":"2016-12-20 09:40:45.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"如果当前节点键值小于其父节点的键值，则把该节点及其子树摘下来作为堆的新树的根节点；其原父节点如果是被标记（marked）节点，则也被摘下来作为堆的新树的根节点；如果其原父节点不是被标记（marked）节点且不是根节点，则其原父节点被加标记。","fragment_id":"降低一个节点的键值_2","scratchTime":"2016-12-20 09:40:45.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"如果堆的新树的根节点被标记（marked），则去除该标记。","fragment_id":"降低一个节点的键值_3","scratchTime":"2016-12-20 09:40:45.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"删除节点","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"把被删除节点的键值调整为负无穷小，然后执行“降低一个节点的键值”算法，然后再执行“删除最小节点”算法。","fragment_id":"删除节点_1","scratchTime":"2016-12-20 09:40:45.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86","content":"^ Fredman, Michael Lawrence; Tarjan, Robert E. Fibonacci heaps and their uses in improved network optimization algorithms (PDF). Journal of the Association for Computing Machinery. 1987, 34 (3): 596–615. doi:10.1145/28869.28874. ","fragment_id":"删除节点_2","scratchTime":"2016-12-20 09:40:45.0","type":"leaf","flag":"text"}]}]}]}
