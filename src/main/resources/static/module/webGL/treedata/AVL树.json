{"totalbranchlevel":2,"branchnum":5,"term_id":63,"name":"AVL树","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":6,"children":[{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"本条目部分链接不符合格式手册规范。跨语言链接及章节标题等处的链接可能需要清理。（2015年12月11日） 请协助改善此条目。参见WP:LINKSTYLE、WP:MOSIW以了解细节。突出显示跨语言链接可以便于检查。","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:47:57.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"AVL树 型态 树 时间 1962 作者 格奥尔吉·阿杰尔松-韦利斯基及E. M. Landis 大O符号 的时间复杂度 平均 最差 空间 O(n) O(n) 搜寻 O(log n) O(log n) 插入 O(log n) O(log n) 删除 O(log n) O(log n)","fragment_id":"摘要_2","scratchTime":"2016-12-20 09:47:57.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"在计算机科学中，AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O（log n）。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者G.M. Adelson-Velsky和E.M. Landis，他们在1962年的论文《An algorithm for the organization of information》中发表了它。","fragment_id":"摘要_3","scratchTime":"2016-12-20 09:47:57.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。","fragment_id":"摘要_4","scratchTime":"2016-12-20 09:47:57.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/thumb/a/a9/Unbalanced_binary_tree.svg/250px-Unbalanced_binary_tree.svg.png","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:47:58.0","type":"leaf","flag":"image"},{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/thumb/0/06/AVLtreef.svg/250px-AVLtreef.svg.png","fragment_id":"摘要_2","scratchTime":"2016-12-20 09:47:58.0","type":"leaf","flag":"image"}]},{"totalbranchlevel":1,"facet_name":"操作","totalbranchnum":2,"type":"branch","totalleafnum":2,"children":[{"totalbranchlevel":0,"facet_name":"删除","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"从AVL树中删除，可以透过把要删除的节点向下旋转成一个叶子节点，接着直接移除这个叶子节点来完成。因为在旋转成叶子节点期间最多有log n个节点被旋转，而每次AVL旋转耗费固定的时间，所以删除处理在整体上耗费O(log n) 时间。","fragment_id":"删除_1","scratchTime":"2016-12-20 09:47:58.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"搜寻","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"可以像普通二叉查找树一样的进行，所以耗费O(log n)时间，因为AVL树总是保持平衡的。不需要特殊的准备，树的结构不会由于查找而改变。（这是与伸展树搜寻相对立的，它会因为搜寻而变更树结构。）","fragment_id":"搜寻_1","scratchTime":"2016-12-20 09:47:58.0","type":"leaf","flag":"text"}]}]},{"totalbranchlevel":0,"facet_name":"实现描述","totalbranchnum":0,"type":"branch","totalleafnum":5,"children":[{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"假设平衡因子是左子树的高度减去右子树的高度所得到的值，又假设由于在二叉排序树上插入节点而失去平衡的最小子树根节点的指针为a（即a是离插入点最近，且平衡因子绝对值超过1的祖先节点），则失去平衡后进行的规律可归纳为下列四种情况：","fragment_id":"实现描述_1","scratchTime":"2016-12-20 09:47:57.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"单向右旋平衡处理LL：由于在*a的左子树根节点的左子树上插入节点，*a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行一次右旋转操作； 单向左旋平衡处理RR：由于在*a的右子树根节点的右子树上插入节点，*a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行一次左旋转操作； 双向旋转（先左后右）平衡处理LR：由于在*a的左子树根节点的右子树上插入节点，*a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。 双向旋转（先右后左）平衡处理RL：由于在*a的右子树根节点的左子树上插入节点，*a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行两次旋转（先右旋后左旋）操作。","fragment_id":"实现描述_2","scratchTime":"2016-12-20 09:47:58.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"在平衡的二叉排序树BBST (Balancing Binary Search Tree)上插入一个新的数据元素e的递归算法可描述如下：","fragment_id":"实现描述_3","scratchTime":"2016-12-20 09:47:58.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"若BBST为空树，则插入一个数据元素为e的新节点作为BBST的根节点，树的深度增1； 若e的关键字和BBST的根节点的关键字相等，则不进行； 若e的关键字小于BBST的根节点的关键字，而且在BBST的左子树中不存在和e有相同关键字的节点，则将e插入在BBST的左子树上，并且当插入之后的左子树深度增加（+1）时，分别就下列不同情况处理之： BBST的根节点的平衡因子为-1（右子树的深度大于左子树的深度，则将根节点的平衡因子更改为0，BBST的深度不变； BBST的根节点的平衡因子为0（左、右子树的深度相等）：则将根节点的平衡因子更改为1，BBST的深度增1； BBST的根节点的平衡因子为1（左子树的深度大于右子树的深度）：则若BBST的左子树根节点的平衡因子为1：则需进行单向右旋平衡处理，并且在右旋处理之后，将根节点和其右子树根节点的平衡因子更改为0，树的深度不变； 若e的关键字大于BBST的根节点的关键字，而且在BBST的右子树中不存在和e有相同关键字的节点，则将e插入在BBST的右子树上，并且当插入之后的右子树深度增加（+1）时，分别就不同情况处理之。","fragment_id":"实现描述_4","scratchTime":"2016-12-20 09:47:58.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"balance(null) -> null;\nbalance({null, _, null}=Tree) -> Tree;\nbalance({Left, Value, Right}=Tree) ->\n\tDiff = count(Left)-count(Right),\n\tif (Diff < 2) and (Diff > -2)\t->\t{balance(Left), Value, balance(Right)};\n\t   (Diff > 1)\t\t\t\t->\tbalance(rotate_right(Tree));\n\t   (Diff< -1)\t\t\t\t->\tbalance(rotate_left(Tree));\n\t   true\t\t\t\t\t->\texit('This is impossible!')\n\tend.\n\nrotate_right({Left, Value, Right}) ->\n\tmerge_max(Left, {null, Value, Right}).\n\nrotate_left({Left, Value, Right}) ->\n\tmerge_min(Right, {Left, Value, null}).\n\nmerge_min({null, Value, Right}, Tree2) ->\n\t{Tree2, Value, Right};\nmerge_min({Left, _, _}, Tree2) ->\n\tmerge_min(Left, Tree2).\n\nmerge_max({Left , Value, null}, Tree2) ->\n\t{Left, Value, Tree2};\nmerge_max({_, _, Right}, Tree2) ->\n\tmerge_max(Right, Tree2).","fragment_id":"实现描述_5","scratchTime":"2016-12-20 09:47:58.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"AVL节点数计算","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"高度为h的AVL树，节点数N最多 2 h − 1 {\\displaystyle 2^{h}-1} ； 最少 Φ h + 2 5 − 1 {\\displaystyle {\\frac {\\Phi ^{h+2}}{\\sqrt {5}}}-1} ( 其中 Φ = 1 + 5 2 = 1.618 {\\displaystyle \\Phi ={\\frac {1+{\\sqrt {5}}}{2}}=1.618} )。 最少节点数n如以费伯纳西数列可以用数学归纳法证明： N h {\\displaystyle N_{h}} = F h + 2 {\\displaystyle F_{h+2}} - 1 ( F h + 2 {\\displaystyle F_{h+2}} 是Fibonacci polynomial)。 即: N 0 {\\displaystyle N_{0}} = 0 (表示AVL Tree高度为0的节点总数) N 1 {\\displaystyle N_{1}} = 1 (表示AVL Tree高度为1的节点总数) N 2 {\\displaystyle N_{2}} = 2 (表示AVL Tree高度为2的节点总数) N h {\\displaystyle N_{h}} = N h − 1 {\\displaystyle N_{h-1}} + N h − 2 {\\displaystyle N_{h-2}} + 1 (表示AVL Tree高度为h的节点总数) 换句话说，当节点数为N时，高度h最多为 l o g Φ ( 5 ∗ ( N + 1 ) ) − 2 {\\displaystyle log_{\\Phi }({\\sqrt {5}}*(N+1))-2} 。","fragment_id":"AVL节点数计算_1","scratchTime":"2016-12-20 09:47:58.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"引用","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"G. Adelson-Velskii and E.M. Landis, \"An algorithm for the organization of information.\" Doklady Akademii Nauk SSSR, 146:263–266, 1962（Russian）. English translation by Myron J. Ricci in Soviet Math. Doklady, 3:1259–1263, 1962.","fragment_id":"引用_1","scratchTime":"2016-12-20 09:47:58.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/AVL%E6%A0%91","content":"Description from the Dictionary of Algorithms and Data Structures AVL Tree Traversal Linked AVL tree C++ AVL Tree Template and C AVL TREE \"Generic Package\" by Walt Karas A Visual Basic AVL Tree Container Class by Jim Harris AVL Trees: Tutorial and C++ Implementation by Brad Appleton Ulm's Oberon Library: AVLTrees The AVL TREE Data Type CNAVLTree Class Reference GNU libavl AVL-trees - balanced binary trees by Alex Konshin Simulation of AVL Trees AVL tree applet Simulation of AVL Trees (DYNAMIC) AVL, Splay and Red/Black Applet","fragment_id":"引用_2","scratchTime":"2016-12-20 09:47:58.0","type":"leaf","flag":"text"}]}]}
