{"totalbranchlevel":2,"branchnum":5,"term_id":72,"name":"伸展树","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":3,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91","content":"伸展树（英语：Splay Tree）是一种二叉查找树，它能在O(log n)内完成插入、查找和删除操作。它是由丹尼尔·斯立特（Daniel Sleator）和罗伯特·塔扬在1985年发明的[1]。","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:49:31.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91","content":"在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。","fragment_id":"摘要_2","scratchTime":"2016-12-20 09:49:31.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91","content":"它的优势在于不需要记录用于平衡树的冗余信息。","fragment_id":"摘要_3","scratchTime":"2016-12-20 09:49:31.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"优点","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91","content":"可靠的性能——它的平均效率不输于其他平衡树[2]。 存储所需的内存少——伸展树无需记录额外的什么值来维护树的信息，相对于其他平衡树，内存占用要小。 支持可持久化——可以将其改造成可持久化伸展树。可持久化数据结构允许查询修改之前数据结构的信息，对于一般的数据结构，每次操作都有可能移除一些信息，而可持久化的数据结构允许在任何时间查询到之前某个版本的信息。可持久化这一特性在函数式编程当中非常有用。另外，可持久化伸展树每次一般操作的均摊复杂度是O(log n)","fragment_id":"优点_1","scratchTime":"2016-12-20 09:49:31.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"缺点","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91","content":"伸展树最显著的缺点是它有可能会变成一条链。这种情况可能发生在以非降顺序访问n个元素之后。然而均摊的最坏情况是对数级的——O(log n)","fragment_id":"缺点_1","scratchTime":"2016-12-20 09:49:31.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"实现","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91","content":"以下是伸展树的C++实现（用指针实现）","fragment_id":"实现_1","scratchTime":"2016-12-20 09:49:31.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91","content":"#include <functional>\n\n#ifndef SPLAY_TREE\n#define SPLAY_TREE\n\ntemplate< typename T, typename Comp = std::less< T > >\nclass splay_tree {\nprivate:\n  Comp comp;\n  unsigned long p_size;\n  \n  struct node {\n    node *left, *right;\n    node *parent;\n    T key;\n    node( const T& init = T( ) ) : left( 0 ), right( 0 ), parent( 0 ), key( init ) { }\n  } *root;\n  \n  void left_rotate( node *x ) {\n    node *y = x->right;\n    x->right = y->left;\n    if( y->left ) y->left->parent = x;\n    y->parent = x->parent;\n    if( !x->parent ) root = y;\n    else if( x == x->parent->left ) x->parent->left = y;\n    else x->parent->right = y;\n    y->left = x;\n    x->parent = y;\n  }\n  \n  void right_rotate( node *x ) {\n    node *y = x->left;\n    x->left = y->right;\n    if( y->right ) y->right->parent = x;\n    y->parent = x->parent;\n    if( !x->parent ) root = y;\n    else if( x == x->parent->left ) x->parent->left = y;\n    else x->parent->right = y;\n    y->right = x;\n    x->parent = y;\n  }\n  \n  void splay( node *x ) {\n    while( x->parent ) {\n      if( !x->parent->parent ) {\n        if( x->parent->left == x ) right_rotate( x->parent );\n        else left_rotate( x->parent );\n      } else if( x->parent->left == x && x->parent->parent->left == x->parent ) {\n        right_rotate( x->parent->parent );\n        right_rotate( x->parent );\n      } else if( x->parent->right == x && x->parent->parent->right == x->parent ) {\n        left_rotate( x->parent->parent );\n        left_rotate( x->parent );\n      } else if( x->parent->left == x && x->parent->parent->right == x->parent ) {\n        right_rotate( x->parent );\n        left_rotate( x->parent );\n      } else {\n        left_rotate( x->parent );\n        right_rotate( x->parent );\n      }\n    }\n  }\n  \n  void replace( node *u, node *v ) {\n    if( !u->parent ) root = v;\n    else if( u == u->parent->left ) u->parent->left = v;\n    else u->parent->right = v;\n    if( v ) v->parent = u->parent;\n  }\n  \n  node* subtree_minimum( node *u ) {\n    while( u->left ) u = u->left;\n    return u;\n  }\n  \n  node* subtree_maximum( node *u ) {\n    while( u->right ) u = u->right;\n    return u;\n  }\npublic:\n  splay_tree( ) : root( 0 ), p_size( 0 ) { }\n  \n  void insert( const T &key ) {\n    node *z = root;\n    node *p = 0;\n    \n    while( z ) {\n      p = z;\n      if( comp( z->key, key ) ) z = z->right;\n      else z = z->left;\n    }\n    \n    z = new node( key );\n    z->parent = p;\n    \n    if( !p ) root = z;\n    else if( comp( p->key, z->key ) ) p->right = z;\n    else p->left = z;\n    \n    splay( z );\n    p_size++;\n  }\n  \n  node* find( const T &key ) {\n    node *z = root;\n    while( z ) {\n      if( comp( z->key, key ) ) z = z->right;\n      else if( comp( key, z->key ) ) z = z->left;\n      else return z;\n    }\n    return 0;\n  }\n        \n  void erase( const T &key ) {\n    node *z = find( key );\n    if( !z ) return;\n    \n    splay( z );\n    \n    if( !z->left ) replace( z, z->right );\n    else if( !z->right ) replace( z, z->left );\n    else {\n      node *y = subtree_minimum( z->right );\n      if( y->parent != z ) {\n        replace( y, y->right );\n        y->right = z->right;\n        y->right->parent = y;\n      }\n      replace( z, y );\n      y->left = z->left;\n      y->left->parent = y;\n    }\n    \n    p_size--;\n  }\n  \n  const T& minimum( ) { return subtree_minimum( root )->key; }\n  const T& maximum( ) { return subtree_maximum( root )->key; }\n  \n  bool empty( ) const { return root == 0; }\n  unsigned long size( ) const { return p_size; }\n};\n\n#endif // SPLAY_TREE","fragment_id":"实现_2","scratchTime":"2016-12-20 09:49:31.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"参考来源","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91","content":"^ Sleator, Daniel D.; Tarjan, Robert E., Self-Adjusting Binary Search Trees (PDF), Journal of the ACM, 1985, 32 (3): 652–686, doi:10.1145/3828.3835 （英语）  ^ Goodrich, Michael; Tamassia, Roberto; Goldwasser, Michael. Data Structures and Algorithms in Java 6. John Wiley & Sons, Inc. : 506. ISBN 978-1-118-77133-4 （英语）. The surprising thing about splaying is that it allows us to guarantee a logarithmic amortized running time, for insertions, deletions, and searches. ","fragment_id":"参考来源_1","scratchTime":"2016-12-20 09:49:31.0","type":"leaf","flag":"text"}]}]}
