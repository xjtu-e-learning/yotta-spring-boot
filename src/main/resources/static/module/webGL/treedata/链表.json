{"totalbranchlevel":2,"branchnum":7,"term_id":70,"name":"链表","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。","fragment_id":"摘要_2","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（\"links\"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。","fragment_id":"摘要_3","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"链表可以在多种编程语言中实现。像Lisp和Scheme这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。","fragment_id":"摘要_4","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"历史","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"链表开发于1955-56，由当时所属于兰德公司（英语：RAND Corporation）的艾伦纽维尔（Allen Newell），克里夫肖（Cliff Shaw）和赫伯特西蒙（Herbert Simon）在他们编写的信息处理语言（IPL）中做为原始数据类型所编写。IPL被作者们用来开发几种早期的人工智能程序，包括逻辑推理机，通用问题解算器和一个计算机象棋程序。","fragment_id":"历史_1","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":1,"facet_name":"结构","totalbranchnum":2,"type":"branch","totalleafnum":2,"children":[{"totalbranchlevel":0,"facet_name":"单向链表","totalbranchnum":0,"type":"branch","totalleafnum":6,"children":[{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。","fragment_id":"单向链表_1","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接","fragment_id":"单向链表_2","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。","fragment_id":"单向链表_3","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"链表最基本的结构是在每个节点保存数据和到下一个节点的地址，在最后一个节点保存一个特殊的结束标记，另外在一个固定的位置保存指向第一个节点的指针，有的时候也会同时储存指向最后一个节点的指针。一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。但是也可以提前把一个节点的位置另外保存起来，然后直接访问。当然如果只是访问数据就没必要了，不如在链表上储存指向实际数据的指针。这样一般是为了访问链表中的下一个或者前一个（需要储存反向的指针，见下面的双向链表）节点。","fragment_id":"单向链表_4","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"相对于下面的双向链表，这种普通的，每个节点只有一个指针的链表也叫单向链表，或者单链表，通常用在每次都只会按顺序遍历这个链表的时候（例如图的邻接表，通常都是按固定顺序访问的）。","fragment_id":"单向链表_5","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"//upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/408px-Singly-linked-list.svg.png","fragment_id":"单向链表_1","scratchTime":"2016-12-20 09:49:08.0","type":"leaf","flag":"image"}]},{"totalbranchlevel":0,"facet_name":"双向链表","totalbranchnum":0,"type":"branch","totalleafnum":6,"children":[{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个连接：一个指向前一个节点，（当此“连接”为第一个“连接”时，指向空值或者空列表）；而另一个指向下一个节点，（当此“连接”为最后一个“连接”时，指向空值或者空列表）","fragment_id":"双向链表_1","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"一个双向链表有三个整数值: 数值, 向后的节点链接, 向前的节点链接","fragment_id":"双向链表_2","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"在一些低级语言中, XOR-linking 提供一种在双向链表中通过用一个词来表示两个链接（前后），我们通常不提倡这种做法。","fragment_id":"双向链表_3","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"双向链表也叫双链表。双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。双向链表也可以配合下面的其他链表的扩展使用。","fragment_id":"双向链表_4","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"由于另外储存了指向链表内容的指针，并且可能会修改相邻的节点，有的时候第一个节点可能会被删除或者在之前添加一个新的节点。这时候就要修改指向首个节点的指针。有一种方便的可以消除这种特殊情况的方法是在最后一个节点之后、第一个节点之前储存一个永远不会被删除或者移动的虚拟节点，形成一个下面说的循环链表。这个虚拟节点之后的节点就是真正的第一个节点。这种情况通常可以用这个虚拟节点直接表示这个链表，对于把链表单独的存在数组里的情况，也可以直接用这个数组表示链表并用第0个或者第-1个（如果编译器支持）节点固定的表示这个虚拟节点。","fragment_id":"双向链表_5","scratchTime":"2016-12-20 09:49:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"//upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Doubly-linked-list.svg/610px-Doubly-linked-list.svg.png","fragment_id":"双向链表_1","scratchTime":"2016-12-20 09:49:08.0","type":"leaf","flag":"image"}]}]},{"totalbranchlevel":0,"facet_name":"链表的应用","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"链表用来构建许多其它数据结构，如堆栈，队列和他们的派生。","fragment_id":"链表的应用_1","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"节点的数据域也可以成为另一个链表。通过这种手段，我们可以用列表来构建许多链性数据结构；这个实例产生于Lisp编程语言，在Lisp中链表是初级数据结构，并且现在成为了常见的基础编程模式。 有时候，链表用来生成联合数组，在这种情况下我们称之为联合数列。这种情况下用链表会优于其它数据结构，如自平对分查找树（self-balancing binary search trees）甚至是一些小的数据集合。不管怎样，一些时候一个链表在这样一个树中创建一个节点子集，并且以此来更有效率地转换这个集合。","fragment_id":"链表的应用_2","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":1,"facet_name":"C代码实例","totalbranchnum":2,"type":"branch","totalleafnum":2,"children":[{"totalbranchlevel":0,"facet_name":"接口声明","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"#ifndef LLIST_H\n#define LLIST_H\n\ntypedef void node_proc_fun_t(void*);\ntypedef int node_comp_fun_t(const void*, const void*);\n\ntypedef void LLIST_T;\n\nLLIST_T *llist_new(int elmsize);\nint llist_delete(LLIST_T *ptr);\n \nint llist_node_append(LLIST_T *ptr, const void *datap);\nint llist_node_prepend(LLIST_T *ptr, const void *datap);\n\nint llist_travel(LLIST_T *ptr, node_proc_fun_t *proc);\n \nvoid llist_node_delete(LLIST_T *ptr, node_comp_fun_t *comp, const void *key); \nvoid *llist_node_find(LLIST_T *ptr, node_comp_fun_t *comp, const void *key);\n\n#endif","fragment_id":"接口声明_1","scratchTime":"2016-12-20 09:49:08.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"接口实现","totalbranchnum":0,"type":"branch","totalleafnum":5,"children":[{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"struct node_st {\n        void *datap;\n        struct node_st *next, *prev;\n};\n\nstruct llist_st {\n        struct node_st head;\n        int elmsize;\n        int elmnr;\n};","fragment_id":"类型确定_1","scratchTime":"2016-12-20 09:49:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"LLIST_T*\nllist_new(int elmsize)\n{\n        struct llist_st *newlist;\n        newlist = malloc(sizeof(struct llist_st));\n        if (newlist == NULL) {\n                return NULL;\n        }\n\n        newlist->head.datap = NULL;\n        newlist->head.next = &newlist->head;\n        newlist->head.prev = &newlist->head;\n\n        newlist->elmsize = elmsize;\n\n        return (void*)newlist;\n}\n\nint\nllist_delete(LLIST_T *ptr)\n{\n        struct llist_st *me=ptr;\n        struct node_st *curr, *save;\n\n        for (curr=me->head.next ; curr!=&me->head ; curr=save) {\n                save=curr->next;\n                free(curr->datap);\n                free(curr);\n        }\n\n        free(me);\n\n        return 0;\n}","fragment_id":"初始化和销毁_1","scratchTime":"2016-12-20 09:49:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"int\nllist_node_append(LLIST_T *ptr, const void *datap)\n{\n        struct llist_st *me=ptr;\n        struct node_st *newnodep;\n\n        newnodep = malloc(sizeof(struct node_st));\n        if (newnodep == NULL) {\n                return -1;\n        }\n        newnodep->datap = malloc(me->elmsize);\n        if (newnodep->datap == NULL) {\n                free(newnodep);\n                return -1;\n        }\n\n        memcpy(newnodep->datap, datap, me->elmsize);\n\n        me->head.prev->next = newnodep;\n        newnodep->prev = me->head.prev;\n        me->head.prev = newnodep;\n        newnodep->next = &me->head;\n\n        return 0;\n}\n\nint \nllist_node_prepend(LLIST_T *ptr, const void *datap){\n    struct llist_st *me=ptr;\n    struct node_st *newnodep;\n \n    newnodep = malloc(sizeof(struct node_st));\n    if (newnodep == NULL) {\n        return -1;\n    }\n    newnodep->datap = malloc(me->elmsize);\n    if (newnodep->datap == NULL) {\n        free(newnodep);\n        return -1;\n    }\n \n    memcpy(newnodep->datap, datap, me->elmsize);\n \n    me->head.next->prev = newnodep;\n    newnodep->next = me->head.next;\n    me->head.next = newnodep;\n    newnodep->prev = &me->head;\n\n    return 0;\n}","fragment_id":"节点插入_1","scratchTime":"2016-12-20 09:49:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"int \nllist_travel(LLIST_T *ptr, node_proc_fun_t *proc){\n    struct llist_st *me=ptr;\n    struct node_st *curr;\n \n    for (curr=me->head.next ; curr!=&me->head ; curr=curr->next)\n        proc(curr->datap);/* proc(something you like)*/\n\n    return 0;\n}","fragment_id":"遍历_1","scratchTime":"2016-12-20 09:49:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"void\nllist_node_delete(LLIST_T *ptr, node_comp_fun_t *comp, const void *key){\n    struct llist_st *me=ptr;\n    struct node_st *curr;\n \n    for (curr=me->head.next;curr!=&me->head;curr=curr->next) {\n        if ( (*comp)(curr->datap, key) == 0 ) {\n            struct node_st *_next,*_prev;\n            _prev = curr->prev,_next = curr->next;\n            _prev->next = _next,_next->prev = _prev;\n\n            free(curr->datap);\n            free(curr);\n            break;\n        }\n    }\n    return; \n}\n\nvoid*\nllist_node_find(LLIST_T *ptr, node_comp_fun_t *comp, const void *key)\n{\n        struct llist_st *me=ptr;\n        struct node_st *curr;\n\n        for (curr=me->head.next;curr!=&me->head;curr=curr->next) {\n                if ( (*comp)(curr->datap, key) == 0 ) {\n                        return curr->datap;\n                }\n        }\n        return NULL;\n}","fragment_id":"删除和查找_1","scratchTime":"2016-12-20 09:49:08.0","type":"leaf","flag":"text"}]}]},{"totalbranchlevel":0,"facet_name":"C宏实例","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"以下代码摘自Linux内核2.6.21.5源码(部分)，展示了链表的另一种实现思路，未采用ANSI C标准，采用GNU C标准，遵从GPL版权许可。","fragment_id":"C宏实例_1","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"struct list_head {\n        struct list_head *next, *prev;\n};\n\n#define LIST_HEAD_INIT(name) { &(name), &(name) }\n\n#define LIST_HEAD(name) \\\n        struct list_head name = LIST_HEAD_INIT(name)\n\nstatic inline void INIT_LIST_HEAD(struct list_head *list)\n{\n        list->next = list;\n        list->prev = list;\n}\n\nstatic inline void __list_add(struct list_head *new,\n                              struct list_head *prev,\n                              struct list_head *next)\n{\n        next->prev = new;\n        new->next = next;\n        new->prev = prev;\n        prev->next = new;\n}\n\nstatic inline void list_add(struct list_head *new, struct list_head *head)\n{\n        __list_add(new, head, head->next);\n}\n\nstatic inline void __list_del(struct list_head * prev, struct list_head * next)\n{\n        next->prev = prev;\n        prev->next = next;\n}\n\n\nstatic inline void list_del(struct list_head *entry)\n{\n        __list_del(entry->prev, entry->next);\n        entry->next = NULL;\n        entry->prev = NULL;\n}\n\n#define __list_for_each(pos, head) \\\n        for (pos = (head)->next; pos != (head); pos = pos->next)\n\n#define list_for_each_entry(pos, head, member)                          \\\n        for (pos = list_entry((head)->next, typeof(*pos), member);      \\\n             prefetch(pos->member.next), &pos->member != (head);        \\\n             pos = list_entry(pos->member.next, typeof(*pos), member))","fragment_id":"C宏实例_2","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"常见用途","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"常用于组织删除、检索较少，而添加、遍历较多的数据。 如果与上述情形相反，应采用其他数据结构或者与其他数据结构组合使用。","fragment_id":"常见用途_1","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","content":"线性表 顺序表 基本数据结构 树 (数据结构)","fragment_id":"常见用途_2","scratchTime":"2016-12-20 09:49:07.0","type":"leaf","flag":"text"}]}]}
