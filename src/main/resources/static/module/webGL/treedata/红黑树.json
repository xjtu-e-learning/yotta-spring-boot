{"totalbranchlevel":2,"branchnum":6,"term_id":31,"name":"红黑树","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，他称之为\"对称二叉B树\"，它现代的名字是在Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在O(log n)时间内做查找，插入和删除，这里的n是树中元素的数目。","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"用途和好处","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如实时应用（real time application）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。","fragment_id":"用途和好处_1","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"红黑树在函数式编程中也特别有用，在这里它们是最常用的持久数据结构（persistent data structure）之一，它们用来构造关联数组和集合，每次插入、删除之后它们能保持为以前的版本。除了O(log n)的时间之外，红黑树的持久版本对每次插入或删除需要O(log n)的空间。","fragment_id":"用途和好处_2","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"红黑树是2-3-4树的一种等同。换句话说，对于每个2-3-4树，都存在至少一个数据元素是同样次序的红黑树。在2-3-4树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得2-3-4树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍2-3-4树的原因，尽管2-3-4树在实践中不经常使用。","fragment_id":"用途和好处_3","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。","fragment_id":"用途和好处_4","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"性质","totalbranchnum":0,"type":"branch","totalleafnum":6,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：","fragment_id":"性质_1","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是NIL节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。","fragment_id":"性质_2","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。","fragment_id":"性质_3","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。","fragment_id":"性质_4","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。为此，本文中我们使用\"nil叶子\"或\"空（null）叶子\"，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。","fragment_id":"性质_5","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/450px-Red-black_tree_example.svg.png","fragment_id":"性质_1","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"image"}]},{"totalbranchlevel":1,"facet_name":"操作","totalbranchnum":3,"type":"branch","totalleafnum":3,"children":[{"totalbranchlevel":0,"facet_name":"插入","totalbranchnum":0,"type":"branch","totalleafnum":21,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"我们首先以二叉查找树的方法增加节点并标记它为红色。（如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。）下面要进行什么操作取决于其他临近节点的颜色。同人类的家族树中一样，我们将使用术语叔父节点来指一个节点的父节点的兄弟节点。注意：","fragment_id":"插入_1","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"性质1和性质3总是保持着。 性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。 性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。","fragment_id":"插入_2","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"在下面的示意图中，将要插入的节点标为N，N的父节点标为P，N的祖父节点标为G，N的叔父节点标为U。在图中展示的任何颜色要么是由它所处情形这些所作的假定，要么是假定所暗含（imply）的。","fragment_id":"插入_3","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"对于每一种情形，我们将使用C示例代码来展示。通过下列函数，可以找到一个节点的叔父和祖父节点：","fragment_id":"插入_4","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"node* grandparent(node *n){\n     return n->parent->parent;\n }\n\n node* uncle(node *n){\n     if(n->parent == grandparent(n)->left)\n         return grandparent (n)->right;\n     else\n         return grandparent (n)->left;\n }","fragment_id":"插入_5","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"情形1:新节点N位于树的根上，没有父节点。在这种情形下，我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑节点数目增加一，性质5匹配。","fragment_id":"插入_6","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void insert_case1(node *n){\n     if(n->parent == NULL)\n         n->color = BLACK;\n     else\n         insert_case2 (n);\n }","fragment_id":"插入_7","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"情形2:新节点的父节点P是黑色，所以性质4没有失效（新节点是红色的）。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所替换的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。","fragment_id":"插入_8","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void insert_case2(node *n){\n     if(n->parent->color == BLACK)\n         return; /* 树仍旧有效*/\n     else\n         insert_case3 (n);\n }","fragment_id":"插入_9","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"注意：在下列情形下我们假定新节点的父节点为红色，所以它有祖父节点；因为如果父节点是根节点，那父节点就应当是黑色。所以新节点总有一个叔父节点，尽管在情形4和5下它可能是叶子节点。","fragment_id":"插入_10","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"情形3:如果父节点P和叔父节点U二者都是红色，（此时新插入节点N做为P的左子节点或右子节点都属于情形3，这里右图仅显示N做为P左子的情形）则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色（用来保持性质5）。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G可能是根节点，这就违反了性质2，也有可能祖父节点G的父节点是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行情形1的整个过程。（把G当成是新加入的节点进行各种情形的检查）","fragment_id":"插入_11","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void insert_case3(node *n){\n     if(uncle(n) != NULL && uncle (n)->color == RED) {\n         n->parent->color = BLACK;\n         uncle (n)->color = BLACK;\n         grandparent (n)->color = RED;\n         insert_case1(grandparent(n));\n     }\n     else\n         insert_case4 (n);\n }","fragment_id":"插入_12","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"注意：在余下的情形下，我们假定父节点P是其父亲G的左子节点。如果它是右子节点，情形4和情形5中的左和右应当对调。","fragment_id":"插入_13","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"情形4:父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色;接着，我们按情形5处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。","fragment_id":"插入_14","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void insert_case4(node *n){\n     if(n == n->parent->right && n->parent == grandparent(n)->left) {\n         rotate_left(n->parent);\n         n = n->left;\n     } else if(n == n->parent->left && n->parent == grandparent(n)->right) {\n         rotate_right(n->parent);\n         n = n->right;\n     }\n     insert_case5 (n);\n }","fragment_id":"插入_15","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"情形5：父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次右旋转；在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色（如果P和G都是红色就违反了性质4，所以G必须是黑色）。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。","fragment_id":"插入_16","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void insert_case5(node *n){\n     n->parent->color = BLACK;\n     grandparent (n)->color = RED;\n     if(n == n->parent->left && n->parent == grandparent(n)->left) {\n         rotate_right(grandparent(n));\n     } else {\n         /* Here, n == n->parent->right && n->parent == grandparent (n)->right */\n         rotate_left(grandparent(n));\n     }\n }","fragment_id":"插入_17","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"注意插入实际上是原地算法，因为上述所有调用都使用了尾部递归。","fragment_id":"插入_18","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png","fragment_id":"插入_1","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"image"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png","fragment_id":"插入_2","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"image"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png","fragment_id":"插入_3","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"image"}]},{"totalbranchlevel":0,"facet_name":"删除","totalbranchnum":0,"type":"branch","totalleafnum":26,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题（为了表述方便，这里所指的儿子，为非叶子节点的儿子）。对于二叉查找树，在删除带有两个非叶子儿子的节点的时候，我们找到要么在它的左子树中的最大元素、要么在它的右子树中的最小元素，并把它的值转移到要删除的节点中（如在这里所展示的那样）。我们接着删除我们从中复制出值的那个节点，它必定有少于两个非叶子的儿子。因为只是复制了一个值，不违反任何性质，这就把问题简化为如何删除最多有一个儿子的节点的问题。它不关心这个节点是最初要删除的节点还是我们从中复制出值的那个节点。","fragment_id":"删除_1","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"在本文余下的部分中，我们只需要讨论删除只有一个儿子的节点（如果它两个儿子都为空，即均为叶子，我们任意将其中一个看作它的儿子）。如果我们删除一个红色节点（此时该节点的儿子将都为叶子节点），它的父亲和儿子一定是黑色的。所以我们可以简单的用它的黑色儿子替换它，并不会破坏性质3和性质4。通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质5。另一种简单情况是在被删除节点是黑色而它的儿子是红色的时候。如果只是去除这个黑色节点，用它的红色儿子顶替上来的话，会破坏性质5，但是如果我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5。","fragment_id":"删除_2","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"需要进一步讨论的是在要删除的节点和它的儿子二者都是黑色的时候，这是一种复杂的情况。我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为N（在新的位置上），称呼它的兄弟（它父亲的另一个儿子）为S。在下面的示意图中，我们还是使用P称呼N的父亲，SL称呼S的左儿子，SR称呼S的右儿子。我们将使用下述函数找到兄弟节点：","fragment_id":"删除_3","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"struct node *\nsibling(struct node *n)\n{\n        if(n == n->parent->left)\n                return n->parent->right;\n        else\n                return n->parent->left;\n}","fragment_id":"删除_4","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"我们可以使用下列代码进行上述的概要步骤，这里的函数replace_node替换child到n在树中的位置。出于方便，在本章节中的代码将假定空叶子被用不是NULL的实际节点对象来表示（在插入章节中的代码可以同任何一种表示一起工作）。","fragment_id":"删除_5","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void\ndelete_one_child(struct node *n)\n{\n        /*\n         * Precondition: n has at most one non-null child.\n         */\n        struct node *child = is_leaf(n->right)? n->left : n->right;\n \n        replace_node(n, child);\n        if(n->color == BLACK){\n                if(child->color == RED)\n                        child->color = BLACK;\n                else\n                        delete_case1 (child);\n        }\n        free (n);\n}","fragment_id":"删除_6","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"如果N和它初始的父亲是黑色，则删除它的父亲导致通过N的路径都比不通过它的路径少了一个黑色节点。因为这违反了性质5，树需要被重新平衡。有几种情形需要考虑：","fragment_id":"删除_7","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"情形1: N是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。","fragment_id":"删除_8","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void\ndelete_case1(struct node *n)\n{\n        if(n->parent != NULL)\n                delete_case2 (n);\n}","fragment_id":"删除_9","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"注意：在情形2、5和6下，我们假定N是它父亲的左儿子。如果它是右儿子，则在这些情形下的左和右应当对调。","fragment_id":"删除_10","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"情形2： S是红色。在这种情形下我们在N的父亲上做左旋转，把红色兄弟转换成N的祖父，我们接着对调N的父亲和祖父的颜色。完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），所以我们可以接下去按情形4、情形5或情形6来处理。 （注意：这里的图中没有显示出来，N是删除了黑色节点后替换上来的子节点，所以这个过程中由P->X->N变成了P->N，实际上是少了一个黑色节点，也可以理解为Parent(Black)和Silbing(Red)那么他们的孩子黑色节点的数目肯定不等，让他们做新兄弟肯定是不平衡的，还需后面继续处理。这里看英文版本的[1]比较的明了）","fragment_id":"删除_11","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void\ndelete_case2(struct node *n)\n{\n        struct node *s = sibling (n);\n \n        if(s->color == RED){\n                n->parent->color = RED;\n                s->color = BLACK;\n                if(n == n->parent->left)\n                        rotate_left(n->parent）;\n                else\n                        rotate_right(n->parent);\n        } \n        delete_case3 (n);\n}","fragment_id":"删除_12","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"情形3： N的父亲、S和S的儿子都是黑色的。在这种情形下，我们简单的重绘S为红色。结果是通过S的所有路径，它们就是以前不通过N的那些路径，都少了一个黑色节点。因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。","fragment_id":"删除_13","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void\ndelete_case3(struct node *n)\n{\n        struct node *s = sibling (n);\n \n        if((n->parent->color == BLACK)&&\n(s->color == BLACK)&&\n(s->left->color == BLACK)&&\n(s->right->color == BLACK)) {\n                s->color = RED;\n                delete_case1(n->parent);\n        } else\n                delete_case4 (n);\n}","fragment_id":"删除_14","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"情形4： S和S的儿子都是黑色，但是N的父亲是红色。在这种情形下，我们简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。","fragment_id":"删除_15","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void\ndelete_case4(struct node *n)\n{\n        struct node *s = sibling (n);\n \n        if（(n->parent->color == RED)&&\n(s->color == BLACK)&&\n(s->left->color == BLACK)&&\n(s->right->color == BLACK)) {\n                s->color = RED;\n                n->parent->color = BLACK;\n        } else\n                delete_case5 (n);\n}","fragment_id":"删除_16","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"情形5： S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子。在这种情形下我们在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。我们接着交换S和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，他的右儿子是红色的，所以我们进入了情形6。N和它的父亲都不受这个变换的影响。","fragment_id":"删除_17","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void\ndelete_case5(struct node *n)\n{\n        struct node *s = sibling (n);\n \n        if（s->color == BLACK){ /* this if statement is trivial, \ndue to Case 2(even though Case two changed the sibling to a sibling's child, \nthe sibling's child can't be red, since no red parent can have a red child). */\n// the following statements just force the red to be on the left of the left of the parent, \n// or right of the right, so case six will rotate correctly.\n                if((n == n->parent->left)&&\n(s->right->color == BLACK)&&\n(s->left->color == RED)) { // this last test is trivial too due to cases 2-4.\n                        s->color = RED;\n                        s->left->color = BLACK;\n                        rotate_right (s);\n                } else if((n == n->parent->right)&&\n(s->left->color == BLACK)&&\n(s->right->color == RED)) {// this last test is trivial too due to cases 2-4.\n                        s->color = RED;\n                        s->right->color = BLACK;\n                        rotate_left (s);\n                }\n        }\n        delete_case6 (n);\n}","fragment_id":"删除_18","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"情形6： S是黑色，S的右儿子是红色，而N是它父亲的左儿子。在这种情形下我们在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先：要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。所以，通过N的路径都增加了一个黑色节点。 此时，如果一个路径不通过N，则有两种可能性： 它通过N的新兄弟。那么它以前和现在都必定通过S和N的父亲，而它们只是交换了颜色。所以路径保持了同样数目的黑色节点。 它通过N的新叔父，S的右儿子。那么它以前通过S、S的父亲和S的右儿子，但是现在只通过S，它被假定为它以前的父亲的颜色，和S的右儿子，它被从红色改变为黑色。合成效果是这个路径通过了同样数目的黑色节点。 在任何情况下，在这些路径上的黑色节点数目都没有改变。所以我们恢复了性质4。在示意图中的白色节点可以是红色或黑色，但是在变换前后都必须指定相同的颜色。","fragment_id":"删除_19","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"void\ndelete_case6(struct node *n)\n{\n        struct node *s = sibling (n);\n \n        s->color = n->parent->color;\n        n->parent->color = BLACK;\n \n        if(n == n->parent->left){\n                s->right->color = BLACK;\n                rotate_left(n->parent);\n        } else {\n                s->left->color = BLACK;\n                rotate_right(n->parent);\n        }\n}","fragment_id":"删除_20","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"同样的，函数调用都使用了尾部递归，所以算法是原地算法。此外，在旋转之后不再做递归调用，所以进行了恒定数目（最多3次）的旋转。","fragment_id":"删除_21","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png","fragment_id":"删除_1","scratchTime":"2016-12-20 09:42:10.0","type":"leaf","flag":"image"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/c/c7/Red-black_tree_delete_case_3.png","fragment_id":"删除_2","scratchTime":"2016-12-20 09:42:10.0","type":"leaf","flag":"image"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/d/d7/Red-black_tree_delete_case_4.png","fragment_id":"删除_3","scratchTime":"2016-12-20 09:42:10.0","type":"leaf","flag":"image"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/3/30/Red-black_tree_delete_case_5.png","fragment_id":"删除_4","scratchTime":"2016-12-20 09:42:10.0","type":"leaf","flag":"image"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/3/31/Red-black_tree_delete_case_6.png","fragment_id":"删除_5","scratchTime":"2016-12-20 09:42:10.0","type":"leaf","flag":"image"}]},{"totalbranchlevel":0,"facet_name":"C++示例代码","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"#define BLACK 1\n#define RED 0\n\nusing namespace std;\n\nclass bst {\nprivate:\n\n    struct Node {\n        int value;\n        bool color;\n        Node *leftTree, *rightTree, *parent;\n\n        Node() {\n            color = RED;\n            leftTree = NULL;\n            rightTree = NULL;\n            parent = NULL;\n            value = 0;\n        }\n\n        Node* grandparent() {\n            if(parent == NULL){\n                return NULL;\n            }\n            return parent->parent;\n        }\n\n        Node* uncle() {\n            if(grandparent(） == NULL) {\n                return NULL;\n            }\n            if(parent == grandparent()->rightTree)\n                return grandparent()->leftTree;\n            else\n                return grandparent()->rightTree;\n        }\n\n        Node* sibling() {\n            if(parent->leftTree == this)\n                return parent->rightTree;\n            else\n                return parent->leftTree;\n        }\n    };\n\n    void rotate_right(Node *p){\n        Node *gp = p->grandparent();\n        Node *fa = p->parent;\n        Node *y = p->rightTree;\n\n        fa->leftTree = y;\n\n        if(y != NIL)\n            y->parent = fa;\n        p->rightTree = fa;\n        fa->parent = p;\n\n        if(root == fa)\n            root = p;\n        p->parent = gp;\n\n        if(gp != NULL){\n            if(gp->leftTree == fa)\n                gp->leftTree = p;\n            else\n                gp->rightTree = p;\n        }\n\n    }\n\n    void rotate_left(Node *p){\n        if(p->parent == NULL){\n            root = p;\n            return;\n        }\n        Node *gp = p->grandparent();\n        Node *fa = p->parent;\n        Node *y = p->leftTree;\n\n        fa->rightTree = y;\n\n        if(y != NIL)\n            y->parent = fa;\n        p->leftTree = fa;\n        fa->parent = p;\n\n        if(root == fa)\n            root = p;\n        p->parent = gp;\n\n        if(gp != NULL){\n            if(gp->leftTree == fa)\n                gp->leftTree = p;\n            else\n                gp->rightTree = p;\n        }\n    }\n\n    void inorder(Node *p){\n        if(p == NIL)\n            return;\n\n        if(p->leftTree)\n            inorder(p->leftTree);\n\n        cout << p->value << \" \";\n                \n        if(p->rightTree)\n            inorder(p->rightTree);\n    }\n\n    string outputColor (bool color) {\n        return color ? \"BLACK\" : \"RED\";\n    }\n\n    Node* getSmallestChild(Node *p){\n        if(p->leftTree == NIL)\n            return p;\n        return getSmallestChild(p->leftTree);\n    }\n\n    bool delete_child(Node *p, int data){\n        if(p->value > data){\n            if(p->leftTree == NIL){\n                return false;\n            }\n            return delete_child(p->leftTree, data);\n        } else if(p->value < data){\n            if(p->rightTree == NIL){\n                return false;\n            }\n            return delete_child(p->rightTree, data);\n        } else if(p->value == data){\n            if(p->rightTree == NIL){\n                delete_one_child (p);\n                return true;\n            }\n            Node *smallest = getSmallestChild(p->rightTree);\n            swap(p->value, smallest->value);\n            delete_one_child (smallest);\n\n            return true;\n        }\n    }\n\n    void delete_one_child(Node *p){\n        Node *child = p->leftTree == NIL ? p->rightTree : p->leftTree;\n        if(p->parent == NULL && p->leftTree == NIL && p->rightTree == NIL){\n            p = NULL;\n            root = p;\n            return;\n        }\n        \n        if(p->parent == NULL){\n            delete  p;\n            child->parent = NULL;\n            root = child;\n            root->color = BLACK;\n            return;\n        }\n        \n        if(p->parent->leftTree == p){\n            p->parent->leftTree = child;\n        } else {\n            p->parent->rightTree = child;\n        }\n        child->parent = p->parent;\n\n        if(p->color == BLACK){\n            if(child->color == RED){\n                child->color = BLACK;\n            } else\n                delete_case (child);\n        }\n\n        delete p;\n    }\n\n    void delete_case(Node *p){\n        if(p->parent == NULL){\n            p->color = BLACK;\n            return;\n        }\n        if(p->sibling()->color == RED) {\n            p->parent->color = RED;\n            p->sibling()->color = BLACK;\n            if(p == p->parent->leftTree)\n                rotate_left(p->sibling());\n            else\n                rotate_right(p->sibling());\n        }\n        if(p->parent->color == BLACK && p->sibling()->color == BLACK\n                && p->sibling()->leftTree->color == BLACK && p->sibling()->rightTree->color == BLACK) {\n            p->sibling()->color = RED;\n            delete_case(p->parent);\n        } else if(p->parent->color == RED && p->sibling()->color == BLACK\n                && p->sibling()->leftTree->color == BLACK && p->sibling()->rightTree->color == BLACK) {\n            p->sibling()->color = RED;\n            p->parent->color = BLACK;\n        } else {\n            if(p->sibling()->color == BLACK) {\n                if(p == p->parent->leftTree && p->sibling()->leftTree->color == RED\n                        && p->sibling()->rightTree->color == BLACK) {\n                    p->sibling()->color = RED;\n                    p->sibling()->leftTree->color = BLACK;\n                    rotate_right(p->sibling()->leftTree);\n                } else if(p == p->parent->rightTree && p->sibling()->leftTree->color == BLACK\n                        && p->sibling()->rightTree->color == RED) {\n                    p->sibling()->color = RED;\n                    p->sibling()->rightTree->color = BLACK;\n                    rotate_left(p->sibling()->rightTree);\n                }\n            }\n            p->sibling()->color = p->parent->color;\n            p->parent->color = BLACK;\n            if(p == p->parent->leftTree){\n                p->sibling()->rightTree->color = BLACK;\n                rotate_left(p->sibling());\n            } else {\n                p->sibling()->leftTree->color = BLACK;\n                rotate_right(p->sibling());\n            }\n        }\n    }\n\n    void insert(Node *p, int data){\n        if(p->value >= data){\n            if(p->leftTree != NIL)\n                insert(p->leftTree, data);\n            else {\n                Node *tmp = new Node();\n                tmp->value = data;\n                tmp->leftTree = tmp->rightTree = NIL;\n                tmp->parent = p;\n                p->leftTree = tmp;\n                insert_case (tmp);\n            }\n        } else {\n            if(p->rightTree != NIL)\n                insert(p->rightTree, data);\n            else {\n                Node *tmp = new Node();\n                tmp->value = data;\n                tmp->leftTree = tmp->rightTree = NIL;\n                tmp->parent = p;\n                p->rightTree = tmp;\n                insert_case (tmp);\n            }\n        }\n    }\n\n    void insert_case(Node *p){\n        if(p->parent == NULL){\n            root = p;\n            p->color = BLACK;\n            return;\n        }\n        if(p->parent->color == RED){\n            if(p->uncle()->color == RED) {\n                p->parent->color = p->uncle()->color = BLACK;\n                p->grandparent()->color = RED;\n                insert_case(p->grandparent());\n            } else {\n                if(p->parent->rightTree == p && p->grandparent()->leftTree == p->parent) {\n                    rotate_left (p);\n                    rotate_right (p);\n                    p->color = BLACK;\n                    p->leftTree->color = p->rightTree->color = RED;\n                } else if(p->parent->leftTree == p && p->grandparent()->rightTree == p->parent) {\n                    rotate_right (p);\n                    rotate_left (p);\n                    p->color = BLACK;\n                    p->leftTree->color = p->rightTree->color = RED;\n                } else if(p->parent->leftTree == p && p->grandparent()->leftTree == p->parent) {\n                    p->parent->color = BLACK;\n                    p->grandparent()->color = RED;\n                    rotate_right(p->parent);\n                } else if(p->parent->rightTree == p && p->grandparent()->rightTree == p->parent) {\n                    p->parent->color = BLACK;\n                    p->grandparent()->color = RED;\n                    rotate_left(p->parent);\n                }\n            }\n        }\n    }\n\n    void DeleteTree(Node *p){\n        if(!p || p == NIL){\n            return;\n        }\n        DeleteTree(p->leftTree);\n        DeleteTree(p->rightTree);\n        delete p;\n    }\npublic:\n\n    bst() {\n        NIL = new Node();\n        NIL->color = BLACK;\n        root = NULL;\n    }\n\n    ~bst() {\n        if (root)\n            DeleteTree (root);\n        delete NIL;\n    }\n\n    void inorder() {\n        if(root == NULL)\n            return;\n        inorder (root);\n        cout << endl;\n    }\n\n    void insert (int x) {\n        if(root == NULL){\n            root = new Node();\n            root->color = BLACK;\n            root->leftTree = root->rightTree = NIL;\n            root->value = x;\n        } else {\n            insert(root, x);\n        }\n    }\n\n    bool delete_value (int data) {\n        return delete_child(root, data);\n    }\nprivate:\n    Node *root, *NIL;\n};","fragment_id":"C++示例代码_1","scratchTime":"2016-12-20 09:42:09.0","type":"leaf","flag":"text"}]}]},{"totalbranchlevel":0,"facet_name":"渐进边界的证明","totalbranchnum":0,"type":"branch","totalleafnum":11,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"包含n个内部节点的红黑树的高度是O(log(n))。","fragment_id":"渐进边界的证明_1","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"h(v) = 以节点v为根的子树的高度。 bh(v) = 从v到子树中任何叶子的黑色节点的数目（如果v是黑色则不计数它，也叫做黑色高度）。","fragment_id":"渐进边界的证明_2","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"引理：以节点v为根的子树有至少 2 b h ( v ) − 1 {\\displaystyle 2^{bh(v)}-1} 个内部节点。","fragment_id":"渐进边界的证明_3","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"如果v的高度是零则它必定是nil，因此bh(v) = 0。所以：","fragment_id":"渐进边界的证明_4","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"2 b h ( v ) − 1 = 2 0 − 1 = 1 − 1 = 0 {\\displaystyle 2^{bh(v)}-1=2^{0}-1=1-1=0}","fragment_id":"渐进边界的证明_5","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"归纳假设：h(v) = k的v有 2 b h ( v ) − 1 − 1 {\\displaystyle 2^{bh(v)-1}-1} 个内部节点暗示了h( v ′ {\\displaystyle v'} ) = k+1的 v ′ {\\displaystyle v'} 有 2 b h ( v ′ ) − 1 {\\displaystyle 2^{bh(v')}-1} 个内部节点。","fragment_id":"渐进边界的证明_6","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"因为 v ′ {\\displaystyle v'} 有h( v ′ {\\displaystyle v'} )> 0所以它是个内部节点。同样的它有黑色高度要么是bh( v ′ {\\displaystyle v'} )要么是bh( v ′ {\\displaystyle v'} )-1（依据 v ′ {\\displaystyle v'} 是红色还是黑色）的两个儿子。通过归纳假设每个儿子都有至少 2 b h ( v ′ ) − 1 − 1 {\\displaystyle 2^{bh(v')-1}-1} 个内部接点，所以 v ′ {\\displaystyle v'} 有：","fragment_id":"渐进边界的证明_7","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"2 b h ( v ′ ) − 1 − 1 + 2 b h ( v ′ ) − 1 − 1 + 1 = 2 b h ( v ′ ) − 1 {\\displaystyle 2^{bh(v')-1}-1+2^{bh(v')-1}-1+1=2^{bh(v')}-1}","fragment_id":"渐进边界的证明_8","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"使用这个引理我们现在可以展示出树的高度是对数性的。因为在从根到叶子的任何路径上至少有一半的节点是黑色（根据红黑树性质4），根的黑色高度至少是h(root)/2。通过引理我们得到：","fragment_id":"渐进边界的证明_9","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"n ⩾ 2 h ( r o o t ) 2 − 1 ↔ log ⁡ ( n + 1 ) ⩾ h ( r o o t ) 2 ↔ h ( r o o t ) ⩽ 2 log ⁡ ( n + 1 ) {\\displaystyle n\\geqslant 2^{\\frac {h(root)}{2}}-1\\leftrightarrow \\;\\log {(n+1)}\\geqslant {\\frac {h(root)}{2}}\\leftrightarrow \\;h(root)\\leqslant 2\\log {(n+1)}}","fragment_id":"渐进边界的证明_10","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"AVL树 B树 dancing tree 伸展树 2-3-4树 Treap","fragment_id":"渐进边界的证明_11","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"引用","totalbranchnum":0,"type":"branch","totalleafnum":3,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"Mathworld: Red-Black Tree San Diego State University: CS 660: Red-Black tree notes, by Roger Whitney Cormen, Leiserson, Rivest, Stein. Introduction to Algorithms. Massachusetts: The MIT Press, 2002. pp273-77. ISBN 0-07-013151-1","fragment_id":"引用_1","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"维基共享资源中相关的多媒体资源：红黑树","fragment_id":"引用_2","scratchTime":"2016-12-20 09:42:07.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","content":"An applet + quick explanation Red/Black Tree Demonstration An example[失效链接]（animated GIF, 200KB） An example[失效链接]（static picture） Another explanation[失效链接]（pictures, source code, and Java interactive animation） Red-Black Tree Demonstration by David M. Howard RBT: A SmallEiffel Red-Black Tree Library libredblack: A C Red-Black Tree Library Red-Black Tree C++ Code[失效链接] Red-Black Trees[失效链接] by Thomas Niemann 红黑树的介绍和实现","fragment_id":"引用_3","scratchTime":"2016-12-20 09:42:08.0","type":"leaf","flag":"text"}]}]}
