{"totalbranchlevel":2,"branchnum":8,"term_id":71,"name":"二元搜寻树","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":6,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树（英语：ordered binary tree），排序二叉树（英语：sorted binary tree），是指一棵空树或者具有下列性质的二叉树：","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:49:18.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。","fragment_id":"摘要_2","scratchTime":"2016-12-20 09:49:18.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。","fragment_id":"摘要_3","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望 O ( log ⁡ n ) {\\displaystyle O(\\log n)} ，最坏 O ( n ) {\\displaystyle O(n)} （数列有序，树退化成线性表）。","fragment_id":"摘要_4","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"虽然二叉查找树的最坏效率是O(n),但它支持动态查询，且有很多改进版的二叉查找树可以使树高为 O ( log ⁡ n ) {\\displaystyle O(\\log n)} ,如SBT,AVL树，红黑树等。故不失为一种好的动态查找方法。","fragment_id":"摘要_5","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/150px-Binary_search_tree.svg.png","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"image"}]},{"totalbranchlevel":0,"facet_name":"二叉搜索树的查找算法","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"若b是空树，则搜索失败，否则： 若x等于b的根节点的数据域之值，则查找成功；否则： 若x小于b的根节点的数据域之值，则搜索左子树；否则： 查找右子树。","fragment_id":"二叉搜索树的查找算法_1","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"/* 以下代码为C++写成，下同*/\nStatus SearchBST(BiTree T, KeyType key, BiTree f, BiTree &p){\n  //在根指针T所指二元查找树中递归地查找其关键字等于key的数据元素，若查找成功，\n  //则指针p指向该数据元素节点，并返回TRUE，否则指针指向查找路径上访问的最后\n  //一个节点并返回FALSE，指针f指向T的双亲，其初始调用值为NULL\n  if(!T) { //查找不成功\n    p=f;\n    return false;\n  }\n  else if (key == T->data.key) { //查找成功\n    p=T;\n    return true;\n  }\n  else if (key < T->data.key) //在左子树中继续查找\n    return SearchBST(T->lchild, key, T, p);\n  else //在右子树中继续查找\n    return SearchBST(T->rchild, key, T, p);\n}","fragment_id":"二叉搜索树的查找算法_2","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"在二叉搜索树插入节点的算法","totalbranchnum":0,"type":"branch","totalleafnum":3,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"向一个二叉搜索树b中插入一个节点s的算法，过程为：","fragment_id":"在二叉搜索树插入节点的算法_1","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"若b是空树，则将s所指结点作为根节点插入，否则： 若s->data等于b的根节点的数据域之值，则返回，否则： 若s->data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则： 把s所指节点插入到右子树中。（新插入节点总是叶子节点）","fragment_id":"在二叉搜索树插入节点的算法_2","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"/*当二元搜寻树T中不存在关键字等于e.key的数据元素时，插入e并返回TRUE，否则返回FALSE*/\nStatus InsertBST(BiTree *T, ElemType e){  \n      if(!T)  \n        {\t    \n            s = new BiTNode;\n            s->data = e; s->lchild = s->rchild = NULL;\n            T=s;\t//被插节点*s为新的根结点\n        }\n      else if(e.key == T->data.key)\n        return false;//关键字等于e.key的数据元素，返回错误\n      if (e.key < T->data.key)\n\tInsertBST(T->lchild, e);\t//将e插入左子树\n      else \n\tInsertBST(T->rchild, e);\t//将e插入右子树\n      return true;\n }","fragment_id":"在二叉搜索树插入节点的算法_3","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"在二叉查找树删除结点的算法","totalbranchnum":0,"type":"branch","totalleafnum":8,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"在二叉查找树删去一个结点，分三种情况讨论：","fragment_id":"在二叉查找树删除结点的算法_1","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"若*p结点为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。 若*p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点*f的左子树（当*p是左子树）或右子树（当*p是右子树）即可，作此修改也不破坏二叉查找树的特性。 若*p结点的左子树和右子树均不空。在删去*p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：其一是令*p的左子树为*f的左/右（依*p是*f的左子树还是右子树而定）子树，*s为*p左子树的最右下的结点，而*p的右子树为*s的右子树；其二是令*p的直接前驱（in-order predecessor）或直接后继（in-order successor）替代*p，然后再从二叉查找树中删去它的直接前驱（或直接后继）。","fragment_id":"在二叉查找树删除结点的算法_2","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"在二叉查找树上删除一个结点的算法如下：","fragment_id":"在二叉查找树删除结点的算法_3","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"Status DeleteBST(BiTree *T, KeyType key){\n  //若二叉查找树T中存在关键字等于key的数据元素时，则删除该数据元素，并返回\n  //TRUE；否则返回FALSE\n  if(!T) \n    return false;\t//不存在关键字等于key的数据元素\n  else{\n    if(key == T->data.key) { \t//  找到关键字等于key的数据元素\n      return Delete(T);\n    }\n    else if(key < T->data.key)\n      return DeleteBST(T->lchild, key);\n    else\n      return DeleteBST(T->rchild, key);\n  }\n}\n\nStatus Delete(BiTree *p){\n  //该节点为叶子节点，直接删除\n  BiTree *q, *s;\n  if (!p->rchild && !p->lchild)\n  {\n      delete p;\n      p = NULL;\n  }\n  else if(!p->rchild){\t//右子树空则只需重接它的左子树\n    q=p->lchild;\n    p->data = p->lchild->data;\n    p->lchild=p->lchild->lchild;\n    p->rchild=p->lchild->rchild;\n\n    delete q;\n  }\n  else if(!p->lchild){\t//左子树空只需重接它的右子树\n    q=p->rchild;\n    p->data = p->rchild->data;\n    p->lchild=p->rchild->lchild;\n    p->rchild=p->rchild->rchild;\n\n    delete q;  }\n  else{\t//左右子树均不空\n    q=p; \n    s=p->lchild;\n    while(s->rchild){ \n      q=s; \n      s=s->rchild;\n    }\t//转左，然后向右到尽头\n    p->data = s->data;\t//s指向被删结点的“前驱”\n    if(q!=p)\t\n      q->rchild = s->lchild;\t//重接*q的右子树\n    else \n      q->lchild = s->lchild;\t//重接*q的左子树\n    delete s;\n  }\n  return true;\n}","fragment_id":"在二叉查找树删除结点的算法_4","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"在C语言中有些编译器不支持为struct Node 节点分配空间，声称这是一个不完全的结构，可使用一个指向该Node的指针为之分配空间。","fragment_id":"在二叉查找树删除结点的算法_5","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"如：sizeof( Probe )，Probe作为二叉树节点在typedef中定义的指针。","fragment_id":"在二叉查找树删除结点的算法_6","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"def find_min(self):   # Gets minimum node (leftmost leaf) in a subtree\n    current_node = self\n    while current_node.left_child:\n        current_node = current_node.left_child\n    return current_node\n\ndef replace_node_in_parent(self, new_value=None):\n    if self.parent:\n        if self == self.parent.left_child:\n            self.parent.left_child = new_value\n        else:\n            self.parent.right_child = new_value\n    if new_value:\n        new_value.parent = self.parent\n\ndef binary_tree_delete(self, key):\n    if key < self.key:\n        self.left_child.binary_tree_delete(key)\n    elif key > self.key:\n        self.right_child.binary_tree_delete(key)\n    else: # delete the key here\n        if self.left_child and self.right_child: # if both children are present\n            successor = self.right_child.find_min()\n            self.key = successor.key\n            successor.binary_tree_delete(successor.key)\n        elif self.left_child:   # if the node has only a *left* child\n            self.replace_node_in_parent(self.left_child)\n        elif self.right_child:  # if the node has only a *right* child\n            self.replace_node_in_parent(self.right_child)\n        else: # this node has no children\n            self.replace_node_in_parent(None)","fragment_id":"在二叉查找树删除结点的算法_7","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"//upload.wikimedia.org/wikipedia/commons/thumb/4/46/Binary_search_tree_delete.svg/480px-Binary_search_tree_delete.svg.png","fragment_id":"在二叉查找树删除结点的算法_1","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"image"}]},{"totalbranchlevel":0,"facet_name":"二叉查找树的遍历","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"中序遍历（in-order traversal）二叉查找树的Python代码：","fragment_id":"二叉查找树的遍历_1","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"def traverse_binary_tree(node, callback):\n    if node is None:\n        return\n    traverse_binary_tree(node.leftChild, callback)\n    callback(node.value)\n    traverse_binary_tree(node.rightChild, callback)","fragment_id":"二叉查找树的遍历_2","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"排序（或称构造）一棵二叉查找树","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"用一组数值建造一棵二叉查找树的同时，也把这组数值进行了排序。其最差时间复杂度为 O ( n 2 ) {\\displaystyle O(n^{2})} 。例如，若该组数值经是有序的（从小到大），则建造出来的二叉查找树的所有节点，都没有左子树。自平衡二叉查找树可以克服上述缺点，其时间复杂度为O(nlog n)。一方面，树排序的问题使得CPU Cache性能较差，特别是当节点是动态内存分配时。而堆排序的CPU Cache性能较好。另一方面，树排序是最优的增量排序（incremental sorting）算法，保持一个数值序列的有序性。","fragment_id":"排序（或称构造）一棵二叉查找树_1","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"def build_binary_tree(values):\n    tree = None\n    for v in values:\n        tree = binary_tree_insert(tree, v)\n    return tree\n\ndef get_inorder_traversal(root):\n    '''\n    Returns a list containing all the values in the tree, starting at *root*.\n    Traverses the tree in-order(leftChild, root, rightChild).\n    '''\n    result = []\n    traverse_binary_tree(root, lambda element: result.append(element))\n    return result","fragment_id":"排序（或称构造）一棵二叉查找树_2","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"二叉查找树性能分析","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"每个结点的 C i {\\displaystyle C_{i}} 为该结点的层次数。最坏情况下，当先后插入的关键字有序时，构成的二叉查找树蜕变为单支树，树的深度为 n {\\displaystyle n} ，其平均查找长度为 n + 1 2 {\\displaystyle {\\frac {n+1}{2}}} （和顺序查找相同），最好的情况是二叉查找树的形态和折半查找的判定树相同，其平均查找长度和 log 2 ⁡ ( n ) {\\displaystyle \\log _{2}(n)} 成正比（ O ( log 2 ⁡ ( n ) ) {\\displaystyle O(\\log _{2}(n))} ）。","fragment_id":"二叉查找树性能分析_1","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"二叉查找树的优化","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"Size Balanced Tree(SBT) 加权平衡树(WBT) AVL树 红黑树 Treap(Tree+Heap)","fragment_id":"二叉查找树的优化_1","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"这些均可以使查找树的高度为 O ( log ⁡ ( n ) ) {\\displaystyle O(\\log(n))}","fragment_id":"二叉查找树的优化_2","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"[显示] 查 论 编 计算机科学中的树 二叉树 二叉查找树（BST） 笛卡尔树 MVP树 Top tree T树 自平衡二叉查找树 AA树 AVL树 左倾红黑树 红黑树 替罪羊树 伸展树 树堆 加权平衡树 B树 B+树 B*树 Bx树 UB树 2-3树 2-3-4树 (a,b)-树 Dancing tree H树 堆 二叉堆 二项堆 斐波那契堆 左偏树 Pairing heap 斜堆 Van Emde Boas tree Trie 后缀树 基数树 三叉查找树 X-快速前缀树 Y-快速前缀树 二叉空间分割（BSP）树 四叉树 八叉树 k-d树 隐式k-d树 VP树 非二叉树 指数树 融合树 区间树 PQ树 Range tree SPQR树 空间数据分割树 R树 R*树 R+树 X树 M树 线段树 希尔伯特R树 优先R树 其他树 散列日历 散列树 Finger tree Order statistic tree Metric tree Cover tree BK树 Doubly chained tree iDistance Link-cut tree Fenwick tree Log-structured merge-tree 树状数组","fragment_id":"二叉查找树的优化_3","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%AF%BB%E6%A0%91","content":"[显示] 查 论 编 排序算法 理论 计算复杂性理论 大O符号 全序关系 列表 稳定性 比较排序 自适应排序 排序网络 整数排序 交换排序 冒泡排序 鸡尾酒排序 奇偶排序 梳排序 侏儒排序 快速排序 臭皮匠排序 Bogo排序 选择排序 选择排序 堆排序 平滑排序 笛卡尔树排序 锦标赛排序 圈排序 插入排序 插入排序 希尔排序 伸展排序 二叉查找树排序 图书馆排序 耐心排序 归并排序 归并排序 梯级归并排序 振荡归并排序 多相归并排序 串列排序 分布排序 美国旗帜排序 珠排序 桶排序 爆炸排序 计数排序 鸽巢排序 相邻图排序 基数排序 闪电排序 插值排序 并发排序 双调排序器 Batcher归并网络 两两排序网络 混合排序 区块排序 Tim排序 内省排序 Spread排序 J排序 其他 拓扑排序 煎饼排序 意粉排序","fragment_id":"二叉查找树的优化_4","scratchTime":"2016-12-20 09:49:19.0","type":"leaf","flag":"text"}]}]}
