{"totalbranchlevel":2,"branchnum":4,"term_id":66,"name":"线段树","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":3,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"关于用以储存区间或线段的数据结构，详见“线段树 (储存区间)”。","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"线段树是一种二叉树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。","fragment_id":"摘要_2","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"对于线段树中的每一个非叶子节点[a,b]，它的左子树表示的区间为[a,(a+b)/2]，右子树表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树。叶节点数目为N，即整个线段区间的长度。","fragment_id":"摘要_3","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":1,"facet_name":"基本操作","totalbranchnum":5,"type":"branch","totalleafnum":5,"children":[{"totalbranchlevel":0,"facet_name":"节点数据向上更新","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"/* 对于区间求和 */\nvoid push_up(int rt) {\n    tree[rt] = tree[rt << 1] + tree[rt << 1 | 1];\n}\n\n/* 对于区间求最大值 */\nvoid push_up(int rt) {\n    tree[rt] = max(tree[rt << 1], tree[rt << 1 | 1]);\n}","fragment_id":"节点数据向上更新_1","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"节点懒惰标记下推","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"对于区间求和, 原子数组值需要加上lazy标记乘以子树所统计的区间长度。 len为父节点统计的区间长度, 则len - (len >> 1)为左子树区间长度, len >> 1为右子树区间长度。","fragment_id":"节点懒惰标记下推_1","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"void push_down(int rt, int len) {\n    tree[rt << 1] += lazy[rt] * (len - (len >> 1));\n    lazy[rt << 1] += lazy[rt];\n    tree[rt << 1 | 1] += lazy[rt] * (len >> 1);\n    lazy[rt << 1 | 1] += lazy[rt];\n    lazy[rt] = 0;\n}","fragment_id":"节点懒惰标记下推_2","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"对于区间求最大值, 子树的值不需要乘以长度, 所以不需要传递参数len。","fragment_id":"节点懒惰标记下推_3","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"void push_down(int rt) {\n    tree[rt << 1] += lazy[rt];\n    lazy[rt << 1] += lazy[rt];\n    tree[rt << 1 | 1] += lazy[rt];\n    lazy[rt << 1 | 1] += lazy[rt];\n    lazy[rt] = 0;\n}","fragment_id":"节点懒惰标记下推_4","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"建树","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"#define lchild rt << 1, l, m\n#define rchild rt << 1 | 1, m + 1, r\nvoid build(int rt = 1, int l = 1, int r = N) {\n    if (l == r) { std::cin >> tree[rt]; return; }\n    int m = (l + r) >> 1;\n    build(lchild); build(rchild);\n    push_up(rt);\n}","fragment_id":"建树_1","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"更新","totalbranchnum":0,"type":"branch","totalleafnum":3,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"#define lchild rt << 1, l, m\n#define rchild rt << 1 | 1, m + 1, r\nvoid update(int p, int delta, int rt = 1, int l = 1, int r = N) {\n    if (l == r) {\n        tree[rt] += delta;\n        return;\n    }\n    int m = (l + r) >> 1;\n    if (p <= m) update(p, delta, lchild);\n    else update(p, delta, rchild);\n    push_up(rt);\n}","fragment_id":"更新_1","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"成段更新, 需要用到lazy标记来提高时间效率","fragment_id":"更新_2","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"#define lchild rt << 1, l, m\n#define rchild rt << 1 | 1, m + 1, r\nvoid update(int L, int R, int delta, int rt = 1, int l = 1, int r = N) {\n    if (L <= l && r <= R) {\n        tree[rt] += delta * (r - l + 1);\n        lazy[rt] += delta;\n        return;\n    }\n    if (lazy[rt]) push_down(rt, r - l + 1);\n    int m = (l + r) >> 1;\n    if (L <= m) update(L, R, delta, lchild);\n    if (R > m)  update(L, R, delta, rchild);\n    push_up(rt);\n}","fragment_id":"更新_3","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"区间查询","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"#define lchild rt << 1, l, m\n#define rchild rt << 1 | 1, m + 1, r\nint query(int L, int R, int rt = 1, int l = 1, int r = N) {\n    if (L <= l && r <= R) return tree[rt];\n    if (lazy[rt]) push_down(rt, r - l + 1);\n    int m = (l + r) >> 1, ret = 0;\n    if (L <= m) ret += query(L, R, lchild);\n    if (R > m)  ret += query(L, R, rchild);\n    return ret;\n}","fragment_id":"区间查询_1","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"}]}]},{"totalbranchlevel":0,"facet_name":"变种","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"zkw线段树是一种自底向上的线段树，由清华大学的张昆玮提出。它相对于传统线段树的优势体现在减少了递归操作和增加了位运算等操作以减少常数[1]。","fragment_id":"变种_1","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"相关链接","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"http://dongxicheng.org/structure/segment-tree/","fragment_id":"相关链接_1","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91","content":"^ 张昆玮. 统计的力量——线段树全接触. ","fragment_id":"相关链接_2","scratchTime":"2016-12-20 09:48:27.0","type":"leaf","flag":"text"}]}]}
