{"totalbranchlevel":2,"branchnum":5,"term_id":8,"name":"树堆","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"树堆（英语：Treap），是有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为 O ( log ⁡ n ) {\\displaystyle O(\\log {n})} 。相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构。","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":1,"facet_name":"介绍","totalbranchnum":3,"type":"branch","totalleafnum":3,"children":[{"totalbranchlevel":0,"facet_name":"插入","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"给节点随机分配一个优先级，先和二叉搜索树的插入一样，先把要插入的点插入到一个叶子上，然后跟维护堆一样，如果当前节点的优先级比根大就旋转，如果当前节点是根的左儿子就右旋如果当前节点是根的右儿子就左旋。","fragment_id":"插入_1","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"由于旋转是 O ( 1 ) {\\displaystyle O(1)} 的，最多进行h次（h是树的高度），插入的复杂度是 O ( h ) {\\displaystyle O(h)} 的，在期望情况下 h = O ( log ⁡ n ) {\\displaystyle h=O(\\log {n})} ，所以它的期望复杂度是 O ( log ⁡ n ) {\\displaystyle O(\\log {n})} 。","fragment_id":"插入_2","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"删除","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"因为Treap满足堆性质，所以只需要把要删除的节点旋转到叶节点上，然后直接删除就可以了。具体的方法就是每次找到优先级最大的儿子，向与其相反的方向旋转，直到那个节点被旋转到了叶节点，然后直接删除。","fragment_id":"删除_1","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"删除最多进行 O ( h ) {\\displaystyle O(h)} 次旋转，期望复杂度是 O ( log ⁡ n ) {\\displaystyle O(\\log {n})} 。","fragment_id":"删除_2","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"查找","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"和一般的二叉搜索树一样，但是由于Treap的随机化结构，Treap中查找的期望复杂度是 O ( log ⁡ n ) {\\displaystyle O(\\log {n})} 。","fragment_id":"查找_1","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"}]}]},{"totalbranchlevel":0,"facet_name":"算法分析","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"二叉搜索树有一个特性，就是每个子树的形态在优先级唯一确定的情况下都是唯一的，不受其他因素影响，也就是说，左子树的形态与树中大于根节点的值无关，右子树亦然。这是因为Treap满足堆的性质，Treap的根节点是优先级最大的那个节点，考虑它的左子树，树根也是子树里面最大的一点，右子树亦然。所以Treap相当于先把所有节点按照优先级排序，然后插入，实质上就相当于以随机顺序建立的二叉搜索树，只不过它并不需要一次读入所有数据，可以一个一个地插入。而当这个随机顺序确定的时候，这个树是唯一的。因此在给定优先级的情况下，只要是用符合要求的操作，通过任何方式得出的Treap都是一样的，所以不改变优先级的情况下，特殊的操作不会造成Treap结构的退化。而改变优先级可能会使Treap变得不够随机以致退化。","fragment_id":"算法分析_1","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"Treap的其它操作的期望复杂度同样是 O ( log ⁡ n ) {\\displaystyle O(\\log {n})} 。","fragment_id":"算法分析_2","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":1,"facet_name":"参考程序","totalbranchnum":2,"type":"branch","totalleafnum":2,"children":[{"totalbranchlevel":0,"facet_name":"Pascal","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"(*\n    Project: Amber Standard Sources Library [ASSL]\n    Author: Amber\n    Title: Treap\n    Category: Data Structure\n    Version: v1.0\n    Remark: XXXXXXXX\n    Tested Problems: N/A\n    Date: 2006-11-16\n *)\n program ASSL_Treap(Input, Output);\n const\n    Infinity = 65535;\n type\n    TIndex = Longint;\n    TKey = Longint;\n    TPriority = Word;\n    PTreapNode = ^TTreapNode;\n    TTreapNode = record\n        Left, Right: PTreapNode;\n        Priority: TPriority;\n        Key: TKey;\n    end;\n var\n    NullNode: PTreapNode;\n \n procedure Initalize;\n begin\n    if NullNode = nil then\n    begin\n        New(NullNode);\n        NullNode^.Left := NullNode;\n        NullNode^.Right := NullNode;\n        NullNode^.Priority := Infinity;\n    end;\n end;\n \n function FindMax(T: PTreapNode): PTreapNode;\n begin\n    if T <> NullNode then\n        while T^.Right <> NullNode do\n            T := T^.Right;\n    Result := T;\n end;\n \n function FindMin(T: PTreapNode): PTreapNode;\n begin\n    if T <> NullNode then\n        while T^.Left <> NullNode do\n            T := T^.Left;\n    Result := T;\n end;\n \n function Find(T: PTreapNode; Key: TKey): PTreapNode;\n begin\n    while T <> NullNode do\n        if Key < T^.Key then\n            T := T^.Left\n        else if Key > T^.Key then\n            T := T^.Right\n        else\n            Break;\n    Result := T;\n end;\n \n function LeftRotate(T: PTreapNode): PTreapNode;\n begin\n    Result := T^.Left;\n    T^.Left := Result^.Right;\n    Result^.Right := T;\n end;\n \n function RightRotate(T: PTreapNode): PTreapNode;\n begin\n    Result := T^.Right;\n    T^.Right := Result^.Left;\n    Result^.Left := T;\n end;\n \n function InsertNode(Key: TKey; T: PTreapNode): PTreapNode;\n begin\n    if T = NullNode then\n    begin\n        New(T);\n        T^.Left := NullNode;\n        T^.Right := NullNode;\n        T^.Key := Key;\n        T^.Priority := Random(65535);\n    end\n    else if Key < T^.Key then\n    begin\n        T^.Left := InsertNode(Key, T^.Left);\n        if T^.Left^.Priority < T^.Priority then\n            T := LeftRotate(T);\n    end\n    else if Key > T^.Key then\n    begin\n        T^.Right := InsertNode(Key, T^.Right);\n        if T^.Right^.Priority < T^.Priority then\n            T := RightRotate(T);\n    end;\n    Result := T;\n end;\n \n function DeleteNode(Key: TKey; T: PTreapNode): PTreapNode;\n begin\n    if T <> NullNode then\n        if Key < T^.Key then\n            T^.Left := DeleteNode(Key, T^.Left)\n        else if Key > T^.Key then\n            T^.Right := DeleteNode(Key, T^.Right)\n        else\n        begin\n            if T^.Left^.Priority < T^.Right^.Priority then\n                T := LeftRotate(T)\n            else\n                T := RightRotate(T);\n            if T <> NullNode then\n                T := DeleteNode(Key, T)\n            else //RightRotate\n            begin\n                Dispose(T^.Left);\n                T^.Left := NullNode;\n            end;\n        end;\n     Result := T;\n end;\n \n procedure Main;\n begin\n     Initalize;\n end;\n begin\n     Main;\n end.","fragment_id":"Pascal_1","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"C++","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"#include <iostream>\n#include <ctime>\n\n#include <cstdlib>\n#define MAX 100\n\nusing namespace std;\n\ntypedef struct\n{\n\tint l,r,key,fix;\n}node;\n\nclass treap\n{\npublic:\n\tnode p[MAX];\n\tint size,root;\n\ttreap()\n\t{\n\t\tsrand(time(0));\n\t\tsize=-1;\n\t\troot=-1;\n\t}\n\n\tvoid rot_l(int &x)\n\t{\n\t\tint y=p[x].r;\n\t\tp[x].r=p[y].l;\n\t\tp[y].l=x;\n\t\tx=y;\n\t}\n\n\tvoid rot_r(int &x)\n\t{\n\t\tint y=p[x].l;\n\t\tp[x].l=p[y].r;\n\t\tp[y].r=x;\n\t\tx=y;\n\t}\n\n\tvoid insert(int &k,int tkey)\n\t{\n\t\tif (k==-1)\n\t\t{\n\t\t\tk=++size;\n\t\t\tp[k].l=p[k].r=-1;\n\t\t\tp[k].key=tkey;\n\t\t\tp[k].fix=rand();\n\t\t}\n\t\telse\n\t\tif (tkey<p[k].key)\n\t\t{\n\t\t\tinsert(p[k].l,tkey);\n\t\t\tif (p[ p[k].l ].fix>p[k].fix)\n\t\t\t\trot_r(k);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tinsert(p[k].r,tkey);\n\t\t\tif (p[ p[k].r ].fix>p[k].fix)\n\t\t\t\trot_l(k);\n\t\t}\n\n\t}\n\n\tvoid remove(int &k,int tkey)\n\t{\n\t\tif (k==-1) return;\n\t\tif (tkey<p[k].key)\n\t\t\tremove(p[k].l,tkey);\n\t\telse if (tkey>p[k].key)\n\t\t\tremove(p[k].r,tkey);\n\t\telse\n\t\t{\n\t\t\tif (p[k].l==-1 && p[k].r==-1)\n\t\t\t\tk=-1;\n\t\t\telse if (p[k].l==-1)\n\t\t\t\tk=p[k].r;\n\t\t\telse if (p[k].r==-1)\n\t\t\t\tk=p[k].l;\n\t\t\telse\n\t\t\tif (p[ p[k].l ].fix < p[ p[k].r ].fix)\n\t\t\t{\n\t\t\t\trot_l(k);\n\t\t\t\tremove(p[k].l,tkey);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trot_r(k);\n\t\t\t\tremove(p[k].r,tkey);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid print(int k)\n\t{\n\t\tif (p[k].l!=-1)\n\t\t\tprint(p[k].l);\n\t\tcout << p[k].key << \" : \" << p[k].fix << endl;\n\t\tif (p[k].r!=-1)\n\t\t\tprint(p[k].r);\n\t}\n};\n\ntreap T;\n\nint main(void)\n{\n\n\tint i;\n\tfor (i = 3; i >= 1;i--)\n\t\tT.insert(T.root,i);\n\tT.print(T.root);\n\tfor (i = 3; i >= 1;i--)\n\t{\n\t\tcout << endl;\n\t\tT.remove(T.root,i);\n\t\tT.print(T.root);\n\t}\n\treturn 0;\n}","fragment_id":"C++_1","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"}]}]},{"totalbranchlevel":0,"facet_name":"与其他结构的比较","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"AVL树 伸展树（Splay Tree） 线段树 红黑树 Size Balanced Tree","fragment_id":"与其他结构的比较_1","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86","content":"Randomized Search Trees(pdf)，有对Treap和它的加权形式的详尽介绍以及复杂度的严格证明","fragment_id":"与其他结构的比较_2","scratchTime":"2016-12-20 09:38:28.0","type":"leaf","flag":"text"}]}]}
