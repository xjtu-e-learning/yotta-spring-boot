{"totalbranchlevel":2,"branchnum":3,"term_id":53,"name":"B树","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"本条目的语调或风格可能不适合百科全书的写作方式。（2013年11月19日） 请根据指南协助改善这篇条目，请在讨论页讨论问题所在及加以改善。","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"提示：本条目的主题不是二叉树（binary tree）。","fragment_id":"摘要_2","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"B树 型态 树 时间 1972 作者 Rudolf Bayer, Edward M. McCreight 大O符号 的时间复杂度 平均 最差 空间 O(n) O(n) 搜寻 O(log n) O(log n) 插入 O(log n) O(log n) 删除 O(log n) O(log n)","fragment_id":"摘要_3","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"在计算机科学中，B树（英语：B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实作上。","fragment_id":"摘要_4","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":1,"facet_name":"概述","totalbranchnum":2,"type":"branch","totalleafnum":2,"children":[{"totalbranchlevel":0,"facet_name":"变体","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"术语Ｂ树可以指一个特定的方案，也可以指大体上一类方案。狭义上，一个Ｂ树在它内部节点中存储键值，但不需在叶子节点上存储这些键值的记录。大体上的一类包含一些变体，如B+树和Ｂ*树。","fragment_id":"变体_1","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"在Ｂ+树，这些键值的拷贝被存储在内部节点；键值和记录存储在叶子节点；另外，一个叶子节点可以包含一个指针，指向另一个叶子节点以加速顺序存取。","fragment_id":"变体_2","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"B*树分支出更多的内部邻居节点以保持内部节点更密集地填充。此变体要求非根节点至少2/3填充，而不是1/2。为了维持这样的结构，当一个节点填满之后将不会再立即分割节点，而是将它的键值与下一个节点共享。当两个节点都填满之后，分割成3个节点。","fragment_id":"变体_3","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"计数B树存储，每一树都带有一个指针和其指向子树的节点数目。这就允许了以键值为序快速查找第N笔记录，或是统计2笔记录之间的记录数目，还有其他很多相关的操作。","fragment_id":"变体_4","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"名字取义","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"Rudolf Bayer 和 Ed McCreight 于1972年，在Boeing Research Labs 工作时发明了B 树，但是他们没有解释B 代表什么意义（如果有的话）。Douglas Comer 解释说: 两位作者从来都没解释过B树的原始意义。正如我们所见，“balanced”， “broad” 或 “bushy” 可能适合。其他人建议字母“B”代表 Boeing。源自于他的赞助，不过，看起来把B树当作“Bayer”树更合适些","fragment_id":"名字取义_1","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"Donald Knuth 在他1980年5月发表的题为“CS144C classroom lecture about disk storage and B-trees”的论文中推测了B树的名字取义，提出“B”可能意味Boeing 或者Bayer 的名字。","fragment_id":"名字取义_2","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"}]}]},{"totalbranchlevel":1,"facet_name":"数据库的问题","totalbranchnum":5,"type":"branch","totalleafnum":5,"children":[{"totalbranchlevel":0,"facet_name":"已排序文件的查找时间","totalbranchnum":0,"type":"branch","totalleafnum":5,"children":[{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"通常，排序和查找算法会被通过大O符号，刻画为比较级别的数值。对一个有N笔记录的已排序表进行二叉查找，打个比方说，可以在O（log2N）比较级完成。如果表有1,000,000笔记录,那么定位其中一笔记录，将在20 个比较级内完成。 log21,000,000 = 19.931...","fragment_id":"已排序文件的查找时间_1","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"大数据库一直以来被存储在磁盘。从磁盘上读取一笔记录，与之后的比较键值操作相比，在花费的运行时间上前者处于支配地位。从磁盘读取记录的时间涉及到一个 寻道时间 和 旋转延迟。寻道时间可能是从0到20或者更多毫秒，旋转延迟平均下来约是旋转周期的一半。对于一个7200 转每分钟的磁盘，旋转周期大约是8.33毫秒。像希捷ST3500320NS这样的磁盘,磁道至磁道的寻道时间为 0.8毫秒，平均读取寻道时间为8.5毫秒。为了简化，假设从磁盘读取花费10毫秒。","fragment_id":"已排序文件的查找时间_2","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"乐观来说，如此，在一百万中定位一笔记录将会话花费20次磁盘读取乘上10毫秒每次读取时间，总共是0.2秒。","fragment_id":"已排序文件的查找时间_3","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"时间花费没有那么糟糕的原因是，独立的记录被成组地记录在磁盘块上。一个磁盘块可能为16 千字节。如果每笔记录大小为160 字节，那么一个块可以存储100 笔记录。上面假设的磁盘读取时间确切地说是读取一个完整块的时间。一旦磁头到达位置，一个或者更多的磁盘块可以以较小的延迟来完成读取。对于100笔记录每块，最后差不多6个比较级是不需要任何磁盘读取的————都在上次读取操作中完成了。","fragment_id":"已排序文件的查找时间_4","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"为进一步加速查找，开始的13或14个比较级（每个需要一次磁盘访问）必须要提速。","fragment_id":"已排序文件的查找时间_5","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"提升查找的索引","totalbranchnum":0,"type":"branch","totalleafnum":5,"children":[{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"较大程度上的提升是通过索引来做到的。在上面的例子中，初始磁盘读取从2个因素限制了查找范围。这基本上可以通过创建一个辅助索引来改善，这个索引包含每块磁盘块上的首笔记录（有时称为稀疏索引）。这个辅助索引可能只有原始数据库的1%大小，但是它可以更快速地被检索。在辅助索引中查找入口可以告诉我们在主数据库中要读去哪一块;查找辅助索引之后，我们只需要读取主数据库中的特定的某一个磁盘分块————通过一次磁盘读取开销。索引可以提供10,000入口，所以，这样最多需要14个比较级。就像主数据库，辅助索引中最后6个左右的比较级可能在相同的磁盘分块上。索引可以在大约8次磁盘读取中完成查找，目标记录会在9次磁盘读取后获得。","fragment_id":"提升查找的索引_1","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"创建辅助索引的窍门是可以重复地给辅助索引创建辅助索引。那样可以实现一个只拥有100 入口，能填满一整个磁盘块的辅助-辅助索引。","fragment_id":"提升查找的索引_2","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"要找到想要的记录，我们只需要读取3次磁盘分块，而不是14次。读取和查找辅助-辅助索引中第一个（而且是唯一的）块，标记了相应的辅助索引中的分块。读取和查找辅助索引的分块，标记了主数据库中相应的分块。我们只需要30毫秒，而不是150毫秒就能获取记录。","fragment_id":"提升查找的索引_3","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"辅助的索引，使得查找问题从约为log2N 磁盘读取开销的二分查找，变成logbN 磁盘读取开销的查找，其中b为分块因素（每分块的入口数目：b = 100 入口每分块;logb1,000,000 = 3 次读取）。","fragment_id":"提升查找的索引_4","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"在实际中，如果主数据库被频繁查找，辅助-辅助索引和大部分的辅助索引可能会存储在磁盘缓存中，所以它们不会产生磁盘读取。","fragment_id":"提升查找的索引_5","scratchTime":"2016-12-20 09:46:21.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"插入和删除带来的麻烦","totalbranchnum":0,"type":"branch","totalleafnum":5,"children":[{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"如果数据库不会改变，那么编制索引就很简单，而且索引永远不需要改变。如果他们会改变，那么管理数据库及其索引就变得非常麻烦。","fragment_id":"插入和删除带来的麻烦_1","scratchTime":"2016-12-20 09:46:22.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"从数据库中删除记录不会引起太大问题。索引可以保持不变，记录只需要标记为已删除。数据库仍然保持有序状态。如果会有很多删除，之后查找和存储就不再那么高效了。","fragment_id":"插入和删除带来的麻烦_2","scratchTime":"2016-12-20 09:46:22.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"在一个有序文件中进行插入将是个灾难，因为需要给插入的记录制造空间。在文件中第一笔记录后插入记录需要把所有记录向后偏移一个位置。如此的操作在实际中实在太过昂贵。","fragment_id":"插入和删除带来的麻烦_3","scratchTime":"2016-12-20 09:46:22.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"一种做法是预留一些空间给插入操作。磁盘块有一些空闲空间允许后来的插入，而不是高密度地填充。这些记录可以被标记为像是已删除的记录。","fragment_id":"插入和删除带来的麻烦_4","scratchTime":"2016-12-20 09:46:22.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"现在，只要块中存在空间，插入和删除都可以很快速。如果一个插入操作在一个块上找不到合适的空间，就在临近的块中寻找，且要调整辅助索引。期望是临近存在足够的空间，以免重新调整大量的块。作为可选方案，可以使用一些非排序的块。","fragment_id":"插入和删除带来的麻烦_5","scratchTime":"2016-12-20 09:46:22.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"B树运用的理念","totalbranchnum":0,"type":"branch","totalleafnum":3,"children":[{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"B树使用了以上所有的想法。特别是：","fragment_id":"B树运用的理念_1","scratchTime":"2016-12-20 09:46:22.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"保持键值有序，以顺序遍历 使用层次化的索引来最小化磁盘读取 使用不完全填充的块来加速插入和删除 通过优雅的遍历算法来保持索引平衡","fragment_id":"B树运用的理念_2","scratchTime":"2016-12-20 09:46:22.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"另外，B树通过保证内部节点至少半满来最小化空间浪费。一棵B树可以处理任意数目的插入和删除。","fragment_id":"B树运用的理念_3","scratchTime":"2016-12-20 09:46:22.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"B树的弊端","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"除非完全重建数据库，否则无法改变键值的最大长度。这使得许多数据库系统将人名截断到70字符之内。","fragment_id":"B树的弊端_1","scratchTime":"2016-12-20 09:46:22.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/B%E6%A0%91","content":"（其他关联数组的实现，例如三元搜索树或者开散列哈希表，可以动态适应任意长度的键值）。","fragment_id":"B树的弊端_2","scratchTime":"2016-12-20 09:46:22.0","type":"leaf","flag":"text"}]}]}]}
