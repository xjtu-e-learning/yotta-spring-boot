{"totalbranchlevel":2,"branchnum":5,"term_id":62,"name":"广度优先搜索","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"广度优先搜索 节点进行广度优先搜索的顺序 概况 类别： 搜索算法 数据结构： 图 时间复杂度： O ( | V | + | E | ) = O ( b d ) {\\displaystyle O(|V|+|E|)=O(b^{d})} 空间复杂度： O ( | V | + | E | ) = O ( b d ) {\\displaystyle O(|V|+|E|)=O(b^{d})} 最佳解： 是 完全性： 是","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"图与树 搜索算法 α–β A* B* 回溯 集束 贝尔曼-福特 最佳优先 双向 Borůvka 分支限界 BFS 大英博物馆 D* DFS 深度限制 迪杰斯特拉 Edmonds Floyd–Warshall 边缘搜索 爬山 IDA* 迭代加深 Johnson 跳点 克鲁斯克尔 字典序BFS 普里姆 SMA* 分类 图算法 搜索算法 相关主题 动态规划 图的遍历 树的遍历 查 论 编","fragment_id":"摘要_2","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。","fragment_id":"摘要_3","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"//upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Breadth-first_tree.svg/300px-Breadth-first_tree.svg.png","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"image"}]},{"totalbranchlevel":0,"facet_name":"作法","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"BFS是一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位址，彻底地搜索整张图，直到找到结果为止。BFS并不使用经验法则算法。","fragment_id":"作法_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。一般的实现里，其邻居节点尚未被检验过的节点会被放置在一个被称为 open 的容器中（例如伫列或是链表），而被检验过的节点则被放置在被称为 closed 的容器中。（open-closed表）","fragment_id":"作法_2","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"以德国城市为范例的地图。城市间有数条道路相连接。 从法兰克福开始执行广度优先搜索算法，所产生的广度优先搜索算法树。 广度优先搜索算法的动画范例","fragment_id":"作法_3","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"//upload.wikimedia.org/wikipedia/commons/thumb/a/ad/MapGermanyGraph.svg/250px-MapGermanyGraph.svg.png","fragment_id":"作法_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"image"}]},{"totalbranchlevel":1,"facet_name":"实现方法","totalbranchnum":2,"type":"branch","totalleafnum":2,"children":[{"totalbranchlevel":0,"facet_name":"C 的实现","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"/**\n* ADDQ (Q, p) - p PUSH 入 Q\n* DELQ (Q) - POP Q 并返回 Q 顶\n* FIRSTADJ (G,v) - v 的第一个邻接点，找不到则返回 -1\n* NEXTADJ (G,v) - v 的下一个邻接点，找不到则返回 -1\n* VISIT (v) - 访问 v\n* visited [] - 是否已访问\n*/\n\n/* 广度优先搜索算法 */\nvoid BFS(VLink G[], int v) {\n  int w;\n  /* 访问 v 并入队 */\n  VISIT(v);\n  visited[v]=1;\n  ADDQ(Q,v);\n  /* 对队列 Q 的各元素 */\n  while(!EMPTYQ(Q)) {\n    v=DELQ(Q);\n    w=FIRSTADJ(G,v);\n    /* 的各邻接点 */\n    do {\n      /* 进行访问和入队 */\n      if(visited[w] == 0) {\n        VISIT(w);\n        ADDQ(Q,w);\n        visited[w]=1;\n      }\n    } while (w=NEXTADJ(G,v)) != -1)\n  }\n}\n\n/* 对图G=(V,E)进行广度优先搜索的主算法 */\nvoid TRAVEL_BFS(VLink G[], bool visited[], int n) {\n  int i;\n  // 清零标记数组\n  for(i = 0; i < n; i ++)\n    visited[i] = 0;\n  for(i = 0; i < n; i ++)\n    if(visited[i] == 0)\n      BFS(G,i);\n}","fragment_id":"C 的实现_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"C++ 的实现","totalbranchnum":0,"type":"branch","totalleafnum":7,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"(这个例子仅针对Binary Search Tree) 定义一个结构体来表达一个节点的结构：","fragment_id":"C++ 的实现_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"struct node\n {\n    int self; //数据\n    node *left; //左节点\n    node *right; //右节点\n };","fragment_id":"C++ 的实现_2","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"那么，我们在搜索一个树的时候，从一个节点开始，能首先获取的是它的两个子节点。例如：","fragment_id":"C++ 的实现_3","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"A是第一个访问的，然后顺序是B和C；然后再是B的子节点，C的子节点。那么我们怎么来保证这个顺序呢？","fragment_id":"C++ 的实现_4","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"这里就应该用queue数据结构，因为queue采用先进先出( first-in-first-out )的顺序。","fragment_id":"C++ 的实现_5","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"使用C++的STL函式库，下面的程序能帮助理解：","fragment_id":"C++ 的实现_6","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"std::queue<node*> visited, unvisited; \n node nodes[9];\n node* current;\n \n unvisited.push(&nodes[0]); //先把root放入unvisited queue\n \n while(!unvisited.empty()) //只有unvisited不空\n {\n    current = (unvisited.front()); //目前应该检验的\n \n    if(current -> left != NULL)\n       unvisited.push(current -> left); //把左边放入queue中\n \n    if(current -> right != NULL) //右边压入。因为QUEUE是一个先进先出的结构构，所以即使后面再压其他东西，依然会先访问这个。\n       unvisited.push(current -> right);\n \n    visited.push(current);\n \n    cout << current -> self << endl;\n \n    unvisited.pop();\n }","fragment_id":"C++ 的实现_7","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"}]}]},{"totalbranchlevel":1,"facet_name":"特性","totalbranchnum":4,"type":"branch","totalleafnum":4,"children":[{"totalbranchlevel":0,"facet_name":"空间复杂度","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"因为所有节点都必须被储存，因此BFS的空间复杂度为O(|V| + |E|)，其中|V|是节点的数目，而|E|是图中边的数目。注：另一种说法称BFS的空间复杂度为 O ( B M ) {\\displaystyle O(B^{M})} ，其中B是最大分支系数，而M是树的最长路径长度。由于对空间的大量需求，因此BFS并不适合解非常大的问题。","fragment_id":"空间复杂度_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"时间复杂度","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"最差情形下，BFS必须寻找所有到可能节点的所有路径，因此其时间复杂度为O(|V| + |E|)，其中|V|是节点的数目，而|E|是图中边的数目。","fragment_id":"时间复杂度_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"完全性","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"广度优先搜索算法具有完全性。这意指无论图形的种类如何，只要目标存在，则BFS一定会找到。然而，若目标不存在，且图为无限大，则BFS将不收敛（不会结束）。","fragment_id":"完全性_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"最佳解","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"若所有边的长度相等，广度优先搜索算法是最佳解——亦即它找到的第一个解，距离根节点的边数目一定最少；但对一般的图来说，BFS并不一定回传最佳解。这是因为当图形为加权图（亦即各边长度不同）时，BFS仍然回传从根节点开始，经过边数目最少的解；而这个解距离根节点的距离不一定最短。这个问题可以使用考虑各边权值，BFS的改良算法成本一致搜寻法来解决。然而，若非加权图形，则所有边的长度相等，BFS就能找到最近的最佳解。","fragment_id":"最佳解_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"}]}]},{"totalbranchlevel":1,"facet_name":"广度优先搜索算法的应用","totalbranchnum":3,"type":"branch","totalleafnum":3,"children":[{"totalbranchlevel":0,"facet_name":"寻找连接元件","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"由起点开始，执行广度优先搜索算法后所经过的所有节点，即为包含起点的一个连接元件。","fragment_id":"寻找连接元件_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"测试是否二分图","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"BFS可以用以测试二分图。从任一节点开始搜寻，并在搜寻过程中给节点不同的标签。例如，给开始点标签0，开始点的所有邻居标签1，开始点所有邻居的邻居标签0……以此类推。若在搜寻过程中，任一节点有跟其相同标签的邻居，则此图就不是二分图。若搜寻结束时这种情形未发生，则此图为一二分图。","fragment_id":"测试是否二分图_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"}]},{"totalbranchlevel":0,"facet_name":"应用于电脑游戏中平面网格","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"BFS可用来解决电脑游戏（例如即时策略游戏）中找寻路径的问题。在这个应用中，使用平面网格来代替图形，而一个格子即是图中的一个节点。所有节点都与它的邻居（上、下、左、右、左上、右上、左下、右下）相接。","fragment_id":"应用于电脑游戏中平面网格_1","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"值得一提的是，当这样使用BFS算法时，首先要先检验上、下、左、右的邻居节点，再检验左上、右上、左下、右下的邻居节点。这是因为BFS趋向于先寻找斜向邻居节点，而不是四方的邻居节点，因此找到的路径将不正确。BFS应该先寻找四方邻居节点，接着才寻找斜向邻居节点1。","fragment_id":"应用于电脑游戏中平面网格_2","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein], Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 22.2: Breadth-first search, pp. 531–539.","fragment_id":"应用于电脑游戏中平面网格_3","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"（英文） 数据结构与算法字典：广度优先搜索 （英文） C++ Boost Graph函式库：广度优先搜索 （英文） 深度与广度优先搜索：解释与源代码 （英文） BFS 动画说明","fragment_id":"应用于电脑游戏中平面网格_4","scratchTime":"2016-12-20 09:47:48.0","type":"leaf","flag":"text"}]}]}]}
